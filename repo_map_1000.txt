Aider v0.37.0
Models: gpt-4o with diff edit format, weak model gpt-3.5-turbo
Git repo: .git with 27 files
Repo-map: using 1000 tokens
Here are summaries of some files present in my git repository.
Do not propose changes to these files, treat them as *read-only*.
If you need to edit any of these files, ask me to *add them to the chat* first.

src/build123d/build_common.py:
⋮...
│class Builder(ABC):
│    """Builder
│
│    Base class for the build123d Builders.
│
│    Args:
│        workplanes: sequence of Union[Face, Plane, Location]: set plane(s) to work on
│        mode (Mode, optional): combination mode. Defaults to Mode.ADD.
│
│    Attributes:
│        mode (Mode): builder's combination mode
⋮...
│    def __init__(
│        self,
│        *workplanes: Union[Face, Plane, Location],
│        mode: Mode = Mode.ADD,
⋮...
│class LocationList:
│    """Location Context
│
│    A stateful context of active locations. At least one must be active
│    at all time. Note that local locations are stored and global locations
│    are returned as a property of the local locations and the currently
│    active workplanes.
│
│    Args:
│        locations (list[Location]): list of locations to add to the context
│
⋮...
│    def __init__(self, locations: list[Location]):
⋮...
│class HexLocations(LocationList):
│    """Location Context: Hex Array
│
│    Creates a context of hexagon array of locations for Part or Sketch. When creating
│    hex locations for an array of circles, set `apothem` to the radius of the circle
│    plus one half the spacing between the circles.
│
│    Args:
│        apothem (float): radius of the inscribed circle
│        xCount (int): number of points ( > 0 )
│        yCount (int): number of points ( > 0 )
⋮...
│    def __init__(
│        self,
│        apothem: float,
│        x_count: int,
│        y_count: int,
│        align: Union[Align, tuple[Align, Align]] = (Align.CENTER, Align.CENTER),
⋮...
│class PolarLocations(LocationList):
│    """Location Context: Polar Array
│
│    Creates a context of polar array of locations for Part or Sketch
│
│    Args:
│        radius (float): array radius
│        count (int): Number of points to push
│        start_angle (float, optional): angle to first point from +ve X axis. Defaults to 0.0.
│        angular_range (float, optional): magnitude of array from start angle. Defaults to 360.0.
│        rotate (bool, optional): Align locations with arc tangents. Defaults to True.
⋮...
│    def __init__(
│        self,
│        radius: float,
│        count: int,
│        start_angle: float = 0.0,
│        angular_range: float = 360.0,
│        rotate: bool = True,
│        endpoint: bool = False,
⋮...
│class Locations(LocationList):
│    """Location Context: Push Points
│
│    Creates a context of locations for Part or Sketch
│
│    Args:
│        pts (Union[VectorLike, Vertex, Location, Face, Plane, Axis] or iterable of same):
│            sequence of points to push
│
│    Attributes:
│        local_locations (list{Location}): locations relative to workplane
│
⋮...
│    def __init__(
│        self,
│        *pts: Union[
│            VectorLike,
│            Vertex,
│            Location,
│            Face,
│            Plane,
│            Axis,
│            Iterable[VectorLike, Vertex, Location, Face, Plane, Axis],
⋮...
│class GridLocations(LocationList):
│    """Location Context: Rectangular Array
│
│    Creates a context of rectangular array of locations for Part or Sketch
│
│    Args:
│        x_spacing (float): horizontal spacing
│        y_spacing (float): vertical spacing
│        x_count (int): number of horizontal points
│        y_count (int): number of vertical points
│        align (Union[Align, tuple[Align, Align]], optional): align min, center, or max of object.
⋮...
│    def __init__(
│        self,
│        x_spacing: float,
│        y_spacing: float,
│        x_count: int,
│        y_count: int,
│        align: Union[Align, tuple[Align, Align]] = (Align.CENTER, Align.CENTER),
⋮...
│class WorkplaneList:
│    """Workplane Context
│
│    A stateful context of active workplanes. At least one must be active
│    at all time.
│
│    Args:
│        workplanes (sequence of Union[Face, Plane, Location]): objects to become planes
│
│    Attributes:
│        workplanes (list[Plane]): list of workplanes
│
⋮...
│    def __init__(self, *workplanes: Union[Face, Plane, Location]):
⋮...

src/build123d/build_line.py:
⋮...
│class BuildLine(Builder):
│    """BuildLine
│
│    The BuildLine class is a subclass of Builder for building lines (objects
│    with length but not area or volume). It has an _obj property that returns
│    the current line being built. The class overrides the faces and solids methods
│    of Builder since they don't apply to lines.
│
│    BuildLine only works with a single workplane which is used to convert tuples
│    as inputs to global coordinates. For example:
│
⋮...
│    def __init__(
│        self,
│        workplane: Union[Face, Plane, Location] = Plane.XY,
│        mode: Mode = Mode.ADD,
⋮...

src/build123d/build_part.py:
⋮...
│class BuildPart(Builder):
│    """BuildPart
│
│    The BuildPart class is another subclass of Builder for building parts
│    (objects with the property of volume) from sketches or 3D objects.
│    It has an _obj property that returns the current part being built, and
│    several pending lists for storing faces, edges, and planes that will be
│    integrated into the final part later. The class overrides the _add_to_pending
│    method of Builder.
│
│    Args:
⋮...
│    def __init__(
│        self,
│        *workplanes: Union[Face, Plane, Location],
│        mode: Mode = Mode.ADD,
⋮...

src/build123d/drafting.py:
⋮...
│class ArrowHead(BaseSketchObject):
│    """Sketch Object: ArrowHead
│
│    Args:
│        size (float): tip to tail length
│        head_type (HeadType, optional): arrow head shape. Defaults to HeadType.CURVED.
│        rotation (float, optional): rotation in degrees. Defaults to 0.
│        mode (Mode, optional): combination mode. Defaults to Mode.ADD.
⋮...
│    def __init__(
│        self,
│        size: float,
│        head_type: HeadType = HeadType.CURVED,
│        rotation: float = 0,
│        mode: Mode = Mode.ADD,
⋮...
│class Arrow(BaseSketchObject):
│    """Sketch Object: Arrow with shaft
│
│    Args:
│        arrow_size (float): arrow head tip to tail length
│        shaft_path (Union[Edge, Wire]): line describing the shaft shape
│        shaft_width (float): line width of shaft
│        head_at_start (bool, optional): Defaults to True.
│        head_type (HeadType, optional): arrow head shape. Defaults to HeadType.CURVED.
│        mode (Mode, optional): _description_. Defaults to Mode.ADD.
⋮...
│    def __init__(
│        self,
│        arrow_size: float,
│        shaft_path: Union[Edge, Wire],
│        shaft_width: float,
│        head_at_start: bool = True,
│        head_type: HeadType = HeadType.CURVED,
│        mode: Mode = Mode.ADD,
⋮...
│class DimensionLine(BaseSketchObject):
│    """Sketch Object: DimensionLine
│
│    Create a dimension line typically for internal measurements.
│    Typically used for (but not restricted to) inside dimensions, a dimension line often
│    as arrows on either side of a dimension or label.
│
│    There are three options depending on the size of the text and length
│    of the dimension line:
│    Type 1) The label and arrows fit within the length of the path
│    Type 2) The text fit within the path and the arrows go outside
⋮...
│    def __init__(
│        self,
│        path: PathDescriptor,
│        draft: Draft = None,
│        sketch: Sketch = None,
│        label: str = None,
│        arrows: tuple[bool, bool] = (True, True),
│        tolerance: Union[float, tuple[float, float]] = None,
│        label_angle: bool = False,
│        mode: Mode = Mode.ADD,
⋮...
│class ExtensionLine(BaseSketchObject):
│    """Sketch Object: Extension Line
│
│    Create a dimension line with two lines extending outward from the part to dimension.
│    Typically used for (but not restricted to) outside dimensions, with a pair of lines
│    extending from the edge of a part to a dimension line.
│
│    Args:
│        border (PathDescriptor): a very general type of input defining the object to
│            be dimensioned. Typically this value would be extracted from the part but is
│            not restricted to this use.
⋮...
│    def __init__(
│        self,
│        border: PathDescriptor,
│        offset: float,
│        draft: Draft,
│        sketch: Sketch = None,
│        label: str = None,
│        arrows: tuple[bool, bool] = (True, True),
│        tolerance: Union[float, tuple[float, float]] = None,
│        label_angle: bool = False,
⋮...
│class TechnicalDrawing(BaseSketchObject):
│    """Sketch Object: TechnicalDrawing
│
│    The border of a technical drawing with external frame and text box.
│
│    Args:
│        designed_by (str, optional): Defaults to "build123d".
│        design_date (date, optional): Defaults to date.today().
│        page_size (PageSize, optional): Defaults to PageSize.A4.
│        title (str, optional): drawing title. Defaults to "Title".
│        sub_title (str, optional): drawing sub title. Defaults to "Sub Title".
⋮...
│    def __init__(
│        self,
│        designed_by: str = "build123d",
│        design_date: date = date.today(),
│        page_size: PageSize = PageSize.A4,
│        title: str = "Title",
│        sub_title: str = "Sub Title",
│        drawing_number: str = "B3D-1",
│        sheet_number: int = None,
│        drawing_scale: float = 1.0,
⋮...

src/build123d/exporters.py:
⋮...
│class Drawing:
│    """A base drawing object"""
│
│    def __init__(
│        self,
│        shape: Shape,
│        *,
│        look_at: VectorLike = None,
│        look_from: VectorLike = (1, -1, 1),
│        look_up: VectorLike = (0, 0, 1),
│        with_hidden: bool = True,
│        focus: Union[float, None] = None,
⋮...
│class ExportDXF(Export2D):
│    """
│    The ExportDXF class provides functionality for exporting 2D shapes to DXF
│    (Drawing Exchange Format) format. DXF is a widely used file format for
│    exchanging CAD (Computer-Aided Design) data between different software
│    applications.
│
│
│    Args:
│        version (str, optional): The DXF version to use for the output file.
│            Defaults to ezdxf.DXF2013.
⋮...
│    def __init__(
│        self,
│        version: str = ezdxf.DXF2013,
│        unit: Unit = Unit.MM,
│        color: Optional[ColorIndex] = None,
│        line_weight: Optional[float] = None,
│        line_type: Optional[LineType] = None,
⋮...
│class ExportSVG(Export2D):
│    """ExportSVG
│
│    SVG file export functionality.
│
│    The ExportSVG class provides functionality for exporting 2D shapes to SVG
│    (Scalable Vector Graphics) format. SVG is a widely used vector graphics format
│    that is supported by web browsers and various graphic editors.
│
│    Args:
│        unit (Unit, optional): The unit used for the exported SVG. It should be one of
⋮...
│    class _Layer:
│        def __init__(
│            self,
│            name: str,
│            fill_color: Union[ColorIndex, RGB, Color, None],
│            line_color: Union[ColorIndex, RGB, Color, None],
│            line_weight: float,
│            line_type: LineType,
⋮...
│    def __init__(
│        self,
│        unit: Unit = Unit.MM,
│        scale: float = 1,
│        margin: float = 0,
│        fit_to_stroke: bool = True,
│        precision: int = 6,
│        fill_color: Union[ColorIndex, RGB, Color, None] = None,
│        line_color: Union[ColorIndex, RGB, Color, None] = Export2D.DEFAULT_COLOR_INDEX,
│        line_weight: float = Export2D.DEFAULT_LINE_WEIGHT,  # in millimeters
⋮...

src/build123d/geometry.py:
⋮...
│class Vector:
│    """Create a 3-dimensional vector
│
│    Args:
│        x (float): x component
│        y (float): y component
│        z (float): z component
│        vec (Union[Vector, Sequence(float), gp_Vec, gp_Pnt, gp_Dir, gp_XYZ]): vector representation
│
│    Note that if no z value is provided it's assumed to be zero. If no values are provided
│    the returned Vector has the value of 0, 0, 0.
│
⋮...
│    @overload
│    def __init__(self, X: float, Y: float, Z: float):  # pragma: no cover
⋮...
│    @overload
│    def __init__(self, X: float, Y: float):  # pragma: no cover
⋮...
│    @overload
│    def __init__(self, v: Vector):  # pragma: no cover
⋮...
│    @overload
│    def __init__(self, v: Sequence[float]):  # pragma: no cover
⋮...
│    @overload
│    def __init__(self, v: Union[gp_Vec, gp_Pnt, gp_Dir, gp_XYZ]):  # pragma: no cover
⋮...
│    @overload
│    def __init__(self):  # pragma: no cover
⋮...
│    def __init__(self, *args, **kwargs):
⋮...
│    def to_tuple(self) -> tuple[float, float, float]:
⋮...
│    def to_pnt(self) -> gp_Pnt:
⋮...
│    def to_dir(self) -> gp_Dir:
⋮...
│class Axis(metaclass=AxisMeta):
│    """Axis
│
│    Axis defined by point and direction
│
│    Args:
│        origin (VectorLike): start point
│        direction (VectorLike): direction
│        edge (Edge): origin & direction defined by start of edge
│
│    Attributes:
⋮...
│    @overload
│    def __init__(self, origin: VectorLike, direction: VectorLike):  # pragma: no cover
⋮...
│    @overload
│    def __init__(self, edge: "Edge"):  # pragma: no cover
⋮...
│    def __init__(self, *args, **kwargs):
⋮...
│class BoundBox:
│    """A BoundingBox for a Shape"""
│
│    def __init__(self, bounding_box: Bnd_Box) -> None:
⋮...
│class Color:
│    """
│    Color object based on OCCT Quantity_ColorRGBA.
│
│    Attributes:
│        wrapped (Quantity_ColorRGBA): the OCP color object
⋮...
│    @overload
│    def __init__(self, q_color: Quantity_ColorRGBA):
⋮...
│    @overload
│    def __init__(self, name: str, alpha: float = 1.0):
⋮...
│    @overload
│    def __init__(self, red: float, green: float, blue: float, alpha: float = 1.0):
⋮...
│    @overload
│    def __init__(self, color_code: int, alpha: int = 0xFF):
⋮...
│    def __init__(self, *args, **kwargs):
⋮...
│    def to_tuple(self):
⋮...
│class Location:
│    """Location in 3D space. Depending on usage can be absolute or relative.
│
│    This class wraps the TopLoc_Location class from OCCT. It can be used to move Shape
│    objects in both relative and absolute manner. It is the preferred type to locate objects
│    in build123d.
│
│    Attributes:
│        wrapped (TopLoc_Location): the OCP location object
│
⋮...
│    @overload
│    def __init__(self):  # pragma: no cover
⋮...
│    @overload
│    def __init__(self, location: Location):  # pragma: no cover
⋮...
│    @overload
│    def __init__(self, translation: VectorLike, angle: float = 0):  # pragma: no cover
⋮...
│    @overload
│    def __init__(
│        self, translation: VectorLike, rotation: RotationLike = None
⋮...
│    @overload
│    def __init__(
│        self,
│        translation: VectorLike,
│        rotation: RotationLike,
│        ordering: Union[Extrinsic, Intrinsic],
⋮...
│    @overload
│    def __init__(self, plane: Plane):  # pragma: no cover
⋮...
│    @overload
│    def __init__(self, plane: Plane, plane_offset: VectorLike):  # pragma: no cover
⋮...
│    @overload
│    def __init__(self, top_loc: TopLoc_Location):  # pragma: no cover
⋮...
│    @overload
│    def __init__(self, gp_trsf: gp_Trsf):  # pragma: no cover
⋮...
│    @overload
│    def __init__(
│        self, translation: VectorLike, direction: VectorLike, angle: float
⋮...
│    def __init__(self, *args):
⋮...
│    def to_tuple(self) -> tuple[tuple[float, float, float], tuple[float, float, float]]:
⋮...
│class Rotation(Location):
│    """Subclass of Location used only for object rotation
│
│    Attributes:
│        X (float): rotation in degrees about X axis
│        Y (float): rotation in degrees about Y axis
│        Z (float): rotation in degrees about Z axis
│        optionally specify rotation ordering with Intrinsic or Extrinsic enums, defaults to Intrins
│
⋮...
│    @overload
│    def __init__(
│        self,
│        rotation: RotationLike,
│        ordering: Union[Extrinsic, Intrinsic] == Intrinsic.XYZ,
⋮...
│    @overload
│    def __init__(
│        self,
│        X: float = 0,
│        Y: float = 0,
│        Z: float = 0,
│        ordering: Union[Extrinsic, Intrinsic] = Intrinsic.XYZ,
⋮...
│    def __init__(self, *args, **kwargs):
⋮...
│class Pos(Location):
│    """A position only sub-class of Location"""
│
│    @overload
│    def __init__(self, v: VectorLike):
⋮...
│    @overload
│    def __init__(self, v: Iterable):
⋮...
│    @overload
│    def __init__(self, X: float = 0, Y: float = 0, Z: float = 0):
⋮...
│    def __init__(self, *args, **kwargs):
⋮...
│class Matrix:
│    """A 3d , 4x4 transformation matrix.
│
│    Used to move geometry in space.
│
│    The provided "matrix" parameter may be None, a gp_GTrsf, or a nested list of
│    values.
│
│    If given a nested list, it is expected to be of the form:
│
│        [[m11, m12, m13, m14],
⋮...
│    @overload
│    def __init__(self) -> None:  # pragma: no cover
⋮...
│    @overload
│    def __init__(self, matrix: Union[gp_GTrsf, gp_Trsf]) -> None:  # pragma: no cover
⋮...
│    @overload
│    def __init__(self, matrix: Sequence[Sequence[float]]) -> None:  # pragma: no cover
⋮...
│    def __init__(self, matrix=None):
⋮...
│class Plane(metaclass=PlaneMeta):
│    """Plane
│
│    A plane is positioned in space with a coordinate system such that the plane is defined by
│    the origin, x_dir (X direction), y_dir (Y direction), and z_dir (Z direction) of this coordinat
│    system, which is the "local coordinate system" of the plane. The z_dir is a vector normal to th
│    plane. The coordinate system is right-handed.
│
│    A plane allows the use of local 2D coordinates, which are later converted to
│    global, 3d coordinates when the operations are complete.
│
⋮...
│    @overload
│    def __init__(self, gp_pln: gp_Pln):  # pragma: no cover
⋮...
│    @overload
│    def __init__(
│        self, face: "Face", x_dir: Optional[VectorLike] = None
⋮...
│    @overload
│    def __init__(self, location: Location):  # pragma: no cover
⋮...
│    @overload
│    def __init__(
│        self,
│        origin: VectorLike,
│        x_dir: VectorLike = None,
│        z_dir: VectorLike = (0, 0, 1),
⋮...
│    def __init__(self, *args, **kwargs):
⋮...

src/build123d/joints.py:
⋮...
│class RigidJoint(Joint):
│    """RigidJoint
│
│    A rigid joint fixes two components to one another.
│
│    Args:
│        label (str): joint label
│        to_part (Union[Solid, Compound], optional): object to attach joint to
│        joint_location (Location): global location of joint
│
│    Attributes:
⋮...
│    def __init__(
│        self,
│        label: str,
│        to_part: Union[Solid, Compound] = None,
│        joint_location: Location = Location(),
⋮...
│class RevoluteJoint(Joint):
│    """RevoluteJoint
│
│    Component rotates around axis like a hinge.
│
│    Args:
│        label (str): joint label
│        to_part (Union[Solid, Compound], optional): object to attach joint to
│        axis (Axis): axis of rotation
│        angle_reference (VectorLike, optional): direction normal to axis defining where
│            angles will be measured from. Defaults to None.
⋮...
│    def __init__(
│        self,
│        label: str,
│        to_part: Union[Solid, Compound] = None,
│        axis: Axis = Axis.Z,
│        angle_reference: VectorLike = None,
│        angular_range: tuple[float, float] = (0, 360),
⋮...
│class LinearJoint(Joint):
│    """LinearJoint
│
│    Component moves along a single axis.
│
│    Args:
│        label (str): joint label
│        to_part (Union[Solid, Compound], optional): object to attach joint to
│        axis (Axis): axis of linear motion
│        range (tuple[float, float], optional): (min,max) position of joint.
│            Defaults to (0, inf).
│
⋮...
│    def __init__(
│        self,
│        label: str,
│        to_part: Union[Solid, Compound] = None,
│        axis: Axis = Axis.Z,
│        linear_range: tuple[float, float] = (0, inf),
⋮...
│class CylindricalJoint(Joint):
│    """CylindricalJoint
│
│    Component rotates around and moves along a single axis like a screw.
│
│    Args:
│        label (str): joint label
│        to_part (Union[Solid, Compound], optional): object to attach joint to
│        axis (Axis): axis of rotation and linear motion
│        angle_reference (VectorLike, optional): direction normal to axis defining where
│            angles will be measured from. Defaults to None.
⋮...
│    def __init__(
│        self,
│        label: str,
│        to_part: Union[Solid, Compound] = None,
│        axis: Axis = Axis.Z,
│        angle_reference: VectorLike = None,
│        linear_range: tuple[float, float] = (0, inf),
│        angular_range: tuple[float, float] = (0, 360),
⋮...
│class BallJoint(Joint):
│    """BallJoint
│
│    A component rotates around all 3 axes using a gimbal system (3 nested rotations).
│
│    Args:
│        label (str): joint label
│        to_part (Union[Solid, Compound], optional): object to attach joint to
│        joint_location (Location): global location of joint
│        angular_range
│            (tuple[ tuple[float, float], tuple[float, float], tuple[float, float] ], optional):
⋮...
│    def __init__(
│        self,
│        label: str,
│        to_part: Union[Solid, Compound] = None,
│        joint_location: Location = Location(),
│        angular_range: tuple[
│            tuple[float, float], tuple[float, float], tuple[float, float]
│        ] = ((0, 360), (0, 360), (0, 360)),
│        angle_reference: Plane = Plane.XY,
⋮...

src/build123d/mesher.py:
⋮...
│class Mesher:
│    """Mesher
│
│    Tool for exporting and importing meshed objects stored in 3MF or STL files.
│
│    Args:
│        unit (Unit, optional): model units. Defaults to Unit.MM.
⋮...
│    def __init__(self, unit: Unit = Unit.MM):
⋮...

src/build123d/objects_curve.py:
⋮...
│class BaseLineObject(Wire):
│    """BaseLineObject
│
│    Base class for all BuildLine objects
│
│    Args:
│        curve (Union[Edge,Wire]): edge to create
│        mode (Mode, optional): combination mode. Defaults to Mode.ADD.
⋮...
│    def __init__(
│        self,
│        curve: Union[Edge, Wire],
│        mode: Mode = Mode.ADD,
⋮...
│class Bezier(BaseLineObject):
│    """Line Object: Bezier Curve
│
│    Create a rational (with weights) or non-rational bezier curve.  The first and last
│    control points represent the start and end of the curve respectively.  If weights
│    are provided, there must be one provided for each control point.
│
│    Args:
│        cntl_pnts (sequence[VectorLike]): points defining the curve
│        weights (list[float], optional): control point weights list. Defaults to None.
│        mode (Mode, optional): combination mode. Defaults to Mode.ADD.
⋮...
│    def __init__(
│        self,
│        *cntl_pnts: VectorLike,
│        weights: list[float] = None,
│        mode: Mode = Mode.ADD,
⋮...
│class CenterArc(BaseLineObject):
│    """Line Object: Center Arc
│
│    Add center arc to the line.
│
│    Args:
│        center (VectorLike): center point of arc
│        radius (float): arc radius
│        start_angle (float): arc staring angle
│        arc_size (float): arc size
│        mode (Mode, optional): combination mode. Defaults to Mode.ADD.
⋮...
│    def __init__(
│        self,
│        center: VectorLike,
│        radius: float,
│        start_angle: float,
│        arc_size: float,
│        mode: Mode = Mode.ADD,
⋮...
│class DoubleTangentArc(BaseLineObject):
│    """Line Object: Double Tangent Arc
│
│    Create an arc defined by a point/tangent pair and another line which the other end
│    is tangent to.
│
│    Contains a solver.
│
│    Args:
│        pnt (VectorLike): starting point of tangent arc
│        tangent (VectorLike): tangent at starting point of tangent arc
⋮...
│    def __init__(
│        self,
│        pnt: VectorLike,
│        tangent: VectorLike,
│        other: Union[Curve, Edge, Wire],
│        keep: Keep = Keep.TOP,
│        mode: Mode = Mode.ADD,
⋮...
│class EllipticalStartArc(BaseLineObject):
│    """Line Object: Elliptical Start Arc
│
│    Makes an arc of an ellipse from the start point.
│
│    Args:
│        start (VectorLike): initial point of arc
│        end (VectorLike): final point of arc
│        x_radius (float): semi-major radius
│        y_radius (float): semi-minor radius
│        rotation (float, optional): the angle from the x-axis of the plane to the x-axis
⋮...
│    def __init__(
│        self,
│        start: VectorLike,
│        end: VectorLike,
│        x_radius: float,
│        y_radius: float,
│        rotation: float = 0.0,
│        large_arc: bool = False,
│        sweep_flag: bool = True,
│        plane: Plane = Plane.XY,
⋮...
│class EllipticalCenterArc(BaseLineObject):
│    """Line Object: Elliptical Center Arc
│
│    Makes an arc of an ellipse from a center point.
│
│    Args:
│        center (VectorLike): ellipse center
│        x_radius (float): x radius of the ellipse (along the x-axis of plane)
│        y_radius (float): y radius of the ellipse (along the y-axis of plane)
│        start_angle (float, optional): Defaults to 0.0.
│        end_angle (float, optional): Defaults to 90.0.
⋮...
│    def __init__(
│        self,
│        center: VectorLike,
│        x_radius: float,
│        y_radius: float,
│        start_angle: float = 0.0,
│        end_angle: float = 90.0,
│        rotation: float = 0.0,
│        angular_direction: AngularDirection = AngularDirection.COUNTER_CLOCKWISE,
│        mode: Mode = Mode.ADD,
⋮...
│class Helix(BaseLineObject):
│    """Line Object: Helix
│
│    Add a helix to the line.
│
│    Args:
│        pitch (float): distance between successive loops
│        height (float): helix size
│        radius (float): helix radius
│        center (VectorLike, optional): center point. Defaults to (0, 0, 0).
│        direction (VectorLike, optional): direction of central axis. Defaults to (0, 0, 1).
⋮...
│    def __init__(
│        self,
│        pitch: float,
│        height: float,
│        radius: float,
│        center: VectorLike = (0, 0, 0),
│        direction: VectorLike = (0, 0, 1),
│        cone_angle: float = 0,
│        lefthand: bool = False,
│        mode: Mode = Mode.ADD,
⋮...
│class FilletPolyline(BaseLineObject):
│    """Line Object: FilletPolyline
│
│    Add a sequence of straight lines defined by successive points that
│    are filleted to a given radius.
│
│    Args:
│        pts (Union[VectorLike, Iterable[VectorLike]]): sequence of two or more points
│        radius (float): radius of filleted corners
│        close (bool, optional): close by generating an extra Edge. Defaults to False.
│        mode (Mode, optional): combination mode. Defaults to Mode.ADD.
│
⋮...
│    def __init__(
│        self,
│        *pts: Union[VectorLike, Iterable[VectorLike]],
│        radius: float,
│        close: bool = False,
│        mode: Mode = Mode.ADD,
⋮...
│class JernArc(BaseLineObject):
│    """JernArc
│
│    Circular tangent arc with given radius and arc_size
│
│    Args:
│        start (VectorLike): start point
│        tangent (VectorLike): tangent at start point
│        radius (float): arc radius
│        arc_size (float): arc size in degrees (negative to change direction)
│        mode (Mode, optional): combination mode. Defaults to Mode.ADD.
│
⋮...
│    def __init__(
│        self,
│        start: VectorLike,
│        tangent: VectorLike,
│        radius: float,
│        arc_size: float,
│        mode: Mode = Mode.ADD,
⋮...
│class Line(BaseLineObject):
│    """Line Object: Line
│
│    Add a straight line defined by two end points.
│
│    Args:
│        pts (Union[VectorLike, Iterable[VectorLike]]): sequence of two points
│        mode (Mode, optional): combination mode. Defaults to Mode.ADD.
│
│    Raises:
│        ValueError: Two point not provided
⋮...
│    def __init__(
│        self, *pts: Union[VectorLike, Iterable[VectorLike]], mode: Mode = Mode.ADD
⋮...
│class IntersectingLine(BaseLineObject):
│    """Intersecting Line Object: Line
│
│    Add a straight line that intersects another line at a given parameter and angle.
│
│    Args:
│        start (VectorLike): start point
│        direction (VectorLike): direction to make line
│        other (Edge): stop at the intersection of other
│        mode (Mode, optional): combination mode. Defaults to Mode.ADD.
│
⋮...
│    def __init__(
│        self,
│        start: VectorLike,
│        direction: VectorLike,
│        other: Union[Curve, Edge, Wire],
│        mode: Mode = Mode.ADD,
⋮...
│class PolarLine(BaseLineObject):
│    """Line Object: Polar Line
│
│    Add line defined by a start point, length and angle.
│
│    Args:
│        start (VectorLike): start point
│        length (float): line length
│        angle (float): angle from the local "X" axis.
│        length_mode (LengthMode, optional): length value specifies a diagonal, horizontal
│            or vertical value. Defaults to LengthMode.DIAGONAL
⋮...
│    def __init__(
│        self,
│        start: VectorLike,
│        length: float,
│        angle: float = None,
│        direction: VectorLike = None,
│        length_mode: LengthMode = LengthMode.DIAGONAL,
│        mode: Mode = Mode.ADD,
⋮...
│class Polyline(BaseLineObject):
│    """Line Object: Polyline
│
│    Add a sequence of straight lines defined by successive point pairs.
│
│    Args:
│        pts (Union[VectorLike, Iterable[VectorLike]]): sequence of two or more points
│        close (bool, optional): close by generating an extra Edge. Defaults to False.
│        mode (Mode, optional): combination mode. Defaults to Mode.ADD.
│
│    Raises:
⋮...
│    def __init__(
│        self,
│        *pts: Union[VectorLike, Iterable[VectorLike]],
│        close: bool = False,
│        mode: Mode = Mode.ADD,
⋮...
│class RadiusArc(BaseLineObject):
│    """Line Object: Radius Arc
│
│    Add an arc defined by two end points and a radius
│
│    Args:
│        start_point (VectorLike): start
│        end_point (VectorLike): end
│        radius (float): radius
│        short_sagitta (bool): If True selects the short sagitta, else the
│            long sagitta crossing the center. Defaults to True.
⋮...
│    def __init__(
│        self,
│        start_point: VectorLike,
│        end_point: VectorLike,
│        radius: float,
│        short_sagitta: bool = True,
│        mode: Mode = Mode.ADD,
⋮...
│class SagittaArc(BaseLineObject):
│    """Line Object: Sagitta Arc
│
│    Add an arc defined by two points and the height of the arc (sagitta).
│
│    Args:
│        start_point (VectorLike): start
│        end_point (VectorLike): end
│        sagitta (float): arc height
│        mode (Mode, optional): combination mode. Defaults to Mode.ADD.
⋮...
│    def __init__(
│        self,
│        start_point: VectorLike,
│        end_point: VectorLike,
│        sagitta: float,
│        mode: Mode = Mode.ADD,
⋮...
│class Spline(BaseLineObject):
│    """Line Object: Spline
│
│    Add a spline through the provided points optionally constrained by tangents.
│
│    Args:
│        pts (Union[VectorLike, Iterable[VectorLike]]): sequence of two or more points
│        tangents (Iterable[VectorLike], optional): tangents at end points. Defaults to None.
│        tangent_scalars (Iterable[float], optional): change shape by amplifying tangent.
│            Defaults to None.
│        periodic (bool, optional): make the spline periodic. Defaults to False.
⋮...
│    def __init__(
│        self,
│        *pts: Union[VectorLike, Iterable[VectorLike]],
│        tangents: Iterable[VectorLike] = None,
│        tangent_scalars: Iterable[float] = None,
│        periodic: bool = False,
│        mode: Mode = Mode.ADD,
⋮...
│class TangentArc(BaseLineObject):
│    """Line Object: Tangent Arc
│
│    Add an arc defined by two points and a tangent.
│
│    Args:
│        pts (Union[VectorLike, Iterable[VectorLike]]): sequence of two points
│        tangent (VectorLike): tangent to constrain arc
│        tangent_from_first (bool, optional): apply tangent to first point. Note, applying
│            tangent to end point will flip the orientation of the arc. Defaults to True.
│        mode (Mode, optional): combination mode. Defaults to Mode.ADD.
│
⋮...
│    def __init__(
│        self,
│        *pts: Union[VectorLike, Iterable[VectorLike]],
│        tangent: VectorLike,
│        tangent_from_first: bool = True,
│        mode: Mode = Mode.ADD,
⋮...
│class ThreePointArc(BaseLineObject):
│    """Line Object: Three Point Arc
│
│    Add an arc generated by three points.
│
│    Args:
│        pts (Union[VectorLike, Iterable[VectorLike]]): sequence of three points
│        mode (Mode, optional): combination mode. Defaults to Mode.ADD.
│
│    Raises:
│        ValueError: Three points must be provided
⋮...
│    def __init__(
│        self, *pts: Union[VectorLike, Iterable[VectorLike]], mode: Mode = Mode.ADD
⋮...

src/build123d/objects_part.py:
⋮...
│class BasePartObject(Part):
│    """BasePartObject
│
│    Base class for all BuildPart objects & operations
│
│    Args:
│        solid (Solid): object to create
│        rotation (RotationLike, optional): angles to rotate about axes. Defaults to (0, 0, 0).
│        align (Union[Align, tuple[Align, Align, Align]], optional): align min, center,
│            or max of object. Defaults to None.
│        mode (Mode, optional): combination mode. Defaults to Mode.ADD.
⋮...
│    def __init__(
│        self,
│        part: Union[Part, Solid],
│        rotation: RotationLike = (0, 0, 0),
│        align: Union[Align, tuple[Align, Align, Align]] = None,
│        mode: Mode = Mode.ADD,
⋮...
│class Box(BasePartObject):
│    """Part Object: Box
│
│    Create a box(es) and combine with part.
│
│    Args:
│        length (float): box size
│        width (float): box size
│        height (float): box size
│        rotation (RotationLike, optional): angles to rotate about axes. Defaults to (0, 0, 0).
│        align (Union[Align, tuple[Align, Align, Align]], optional): align min, center,
⋮...
│    def __init__(
│        self,
│        length: float,
│        width: float,
│        height: float,
│        rotation: RotationLike = (0, 0, 0),
│        align: Union[Align, tuple[Align, Align, Align]] = (
│            Align.CENTER,
│            Align.CENTER,
│            Align.CENTER,
⋮...
│class Cone(BasePartObject):
│    """Part Object: Cone
│
│    Create a cone(s) and combine with part.
│
│    Args:
│        bottom_radius (float): cone size
│        top_radius (float): top size, could be zero
│        height (float): cone size
│        arc_size (float, optional): angular size of cone. Defaults to 360.
│        rotation (RotationLike, optional): angles to rotate about axes. Defaults to (0, 0, 0).
⋮...
│    def __init__(
│        self,
│        bottom_radius: float,
│        top_radius: float,
│        height: float,
│        arc_size: float = 360,
│        rotation: RotationLike = (0, 0, 0),
│        align: Union[Align, tuple[Align, Align, Align]] = (
│            Align.CENTER,
│            Align.CENTER,
⋮...
│class CounterBoreHole(BasePartObject):
│    """Part Operation: Counter Bore Hole
│
│    Create a counter bore hole in part.
│
│    Args:
│        radius (float): hole size
│        counter_bore_radius (float): counter bore size
│        counter_bore_depth (float): counter bore depth
│        depth (float, optional): hole depth - None implies through part. Defaults to None.
│        mode (Mode, optional): combination mode. Defaults to Mode.SUBTRACT.
⋮...
│    def __init__(
│        self,
│        radius: float,
│        counter_bore_radius: float,
│        counter_bore_depth: float,
│        depth: float = None,
│        mode: Mode = Mode.SUBTRACT,
⋮...
│class CounterSinkHole(BasePartObject):
│    """Part Operation: Counter Sink Hole
│
│    Create a counter sink hole in part.
│
│    Args:
│        radius (float): hole size
│        counter_sink_radius (float): counter sink size
│        depth (float, optional): hole depth - None implies through part. Defaults to None.
│        counter_sink_angle (float, optional): cone angle. Defaults to 82.
│        mode (Mode, optional): combination mode. Defaults to Mode.SUBTRACT.
⋮...
│    def __init__(
│        self,
│        radius: float,
│        counter_sink_radius: float,
│        depth: float = None,
│        counter_sink_angle: float = 82,  # Common tip angle
│        mode: Mode = Mode.SUBTRACT,
⋮...
│class Cylinder(BasePartObject):
│    """Part Object: Cylinder
│
│    Create a cylinder(s) and combine with part.
│
│    Args:
│        radius (float): cylinder size
│        height (float): cylinder size
│        arc_size (float, optional): angular size of cone. Defaults to 360.
│        rotation (RotationLike, optional): angles to rotate about axes. Defaults to (0, 0, 0).
│        align (Union[Align, tuple[Align, Align, Align]], optional): align min, center,
⋮...
│    def __init__(
│        self,
│        radius: float,
│        height: float,
│        arc_size: float = 360,
│        rotation: RotationLike = (0, 0, 0),
│        align: Union[Align, tuple[Align, Align, Align]] = (
│            Align.CENTER,
│            Align.CENTER,
│            Align.CENTER,
⋮...
│class Hole(BasePartObject):
│    """Part Operation: Hole
│
│    Create a hole in part.
│
│    Args:
│        radius (float): hole size
│        depth (float, optional): hole depth - None implies through part. Defaults to None.
│        mode (Mode, optional): combination mode. Defaults to Mode.SUBTRACT.
⋮...
│    def __init__(
│        self,
│        radius: float,
│        depth: float = None,
│        mode: Mode = Mode.SUBTRACT,
⋮...
│class Sphere(BasePartObject):
│    """Part Object: Sphere
│
│    Create a sphere(s) and combine with part.
│
│    Args:
│        radius (float): sphere size
│        arc_size1 (float, optional): angular size of sphere. Defaults to -90.
│        arc_size2 (float, optional): angular size of sphere. Defaults to 90.
│        arc_size3 (float, optional): angular size of sphere. Defaults to 360.
│        rotation (RotationLike, optional): angles to rotate about axes. Defaults to (0, 0, 0).
⋮...
│    def __init__(
│        self,
│        radius: float,
│        arc_size1: float = -90,
│        arc_size2: float = 90,
│        arc_size3: float = 360,
│        rotation: RotationLike = (0, 0, 0),
│        align: Union[Align, tuple[Align, Align, Align]] = (
│            Align.CENTER,
│            Align.CENTER,
⋮...
│class Torus(BasePartObject):
│    """Part Object: Torus
│
│    Create a torus(es) and combine with part.
│
│
│    Args:
│        major_radius (float): torus size
│        minor_radius (float): torus size
│        major_arc_size (float, optional): angular size of torus. Defaults to 0.
│        minor_arc_size (float, optional): angular size or torus. Defaults to 360.
⋮...
│    def __init__(
│        self,
│        major_radius: float,
│        minor_radius: float,
│        minor_start_angle: float = 0,
│        minor_end_angle: float = 360,
│        major_angle: float = 360,
│        rotation: RotationLike = (0, 0, 0),
│        align: Union[Align, tuple[Align, Align, Align]] = (
│            Align.CENTER,
⋮...
│class Wedge(BasePartObject):
│    """Part Object: Wedge
│
│    Create a wedge(s) and combine with part.
│
│    Args:
│        xsize (float): distance along the X axis
│        ysize (float): distance along the Y axis
│        zsize (float): distance along the Z axis
│        xmin (float): minimum X location
│        zmin (float): minimum Z location
⋮...
│    def __init__(
│        self,
│        xsize: float,
│        ysize: float,
│        zsize: float,
│        xmin: float,
│        zmin: float,
│        xmax: float,
│        zmax: float,
│        rotation: RotationLike = (0, 0, 0),
⋮...

src/build123d/objects_sketch.py:
⋮...
│class BaseSketchObject(Sketch):
│    """BaseSketchObject
│
│    Base class for all BuildSketch objects
│
│    Args:
│        face (Face): face to create
│        rotation (float, optional): angles to rotate objects. Defaults to 0.
│        align (Union[Align, tuple[Align, Align]], optional): align min, center, or max of object.
│            Defaults to None.
│        mode (Mode, optional): combination mode. Defaults to Mode.ADD.
⋮...
│    def __init__(
│        self,
│        obj: Union[Compound, Face],
│        rotation: float = 0,
│        align: Union[Align, tuple[Align, Align]] = None,
│        mode: Mode = Mode.ADD,
⋮...
│class Circle(BaseSketchObject):
│    """Sketch Object: Circle
│
│    Add circle(s) to the sketch.
│
│    Args:
│        radius (float): circle size
│        align (Union[Align, tuple[Align, Align]], optional): align min, center, or max of object.
│            Defaults to (Align.CENTER, Align.CENTER).
│        mode (Mode, optional): combination mode. Defaults to Mode.ADD.
⋮...
│    def __init__(
│        self,
│        radius: float,
│        align: Union[Align, tuple[Align, Align]] = (Align.CENTER, Align.CENTER),
│        mode: Mode = Mode.ADD,
⋮...
│class Ellipse(BaseSketchObject):
│    """Sketch Object: Ellipse
│
│    Add ellipse(s) to sketch.
│
│    Args:
│        x_radius (float): horizontal radius
│        y_radius (float): vertical radius
│        rotation (float, optional): angles to rotate objects. Defaults to 0.
│        align (Union[Align, tuple[Align, Align]], optional): align min, center, or max of object.
│            Defaults to (Align.CENTER, Align.CENTER).
⋮...
│    def __init__(
│        self,
│        x_radius: float,
│        y_radius: float,
│        rotation: float = 0,
│        align: Union[Align, tuple[Align, Align]] = (Align.CENTER, Align.CENTER),
│        mode: Mode = Mode.ADD,
⋮...
│class Polygon(BaseSketchObject):
│    """Sketch Object: Polygon
│
│    Add polygon(s) defined by given sequence of points to sketch.
│
│    Note that the order of the points define the normal of the Face that is created in
│    Algebra mode, where counter clockwise order creates Faces with their normal being up
│    while a clockwise order will have a normal that is down.  In Builder mode, all Faces
│    added to the sketch are up.
│
│    Args:
⋮...
│    def __init__(
│        self,
│        *pts: Union[VectorLike, Iterable[VectorLike]],
│        rotation: float = 0,
│        align: Union[Align, tuple[Align, Align]] = (Align.CENTER, Align.CENTER),
│        mode: Mode = Mode.ADD,
⋮...
│class Rectangle(BaseSketchObject):
│    """Sketch Object: Rectangle
│
│    Add rectangle(s) to sketch.
│
│    Args:
│        width (float): horizontal size
│        height (float): vertical size
│        rotation (float, optional): angles to rotate objects. Defaults to 0.
│        align (Union[Align, tuple[Align, Align]], optional): align min, center, or max of object.
│            Defaults to (Align.CENTER, Align.CENTER).
⋮...
│    def __init__(
│        self,
│        width: float,
│        height: float,
│        rotation: float = 0,
│        align: Union[Align, tuple[Align, Align]] = (Align.CENTER, Align.CENTER),
│        mode: Mode = Mode.ADD,
⋮...
│class RectangleRounded(BaseSketchObject):
│    """Sketch Object: RectangleRounded
│
│    Add rectangle(s) with filleted corners to sketch.
│
│    Args:
│        width (float): horizontal size
│        height (float): vertical size
│        radius (float): fillet radius
│        rotation (float, optional): angles to rotate objects. Defaults to 0.
│        align (Union[Align, tuple[Align, Align]], optional): align min, center, or max of object.
⋮...
│    def __init__(
│        self,
│        width: float,
│        height: float,
│        radius: float,
│        rotation: float = 0,
│        align: Union[Align, tuple[Align, Align]] = (Align.CENTER, Align.CENTER),
│        mode: Mode = Mode.ADD,
⋮...
│class RegularPolygon(BaseSketchObject):
│    """Sketch Object: Regular Polygon
│
│    Add regular polygon(s) to sketch.
│
│    Args:
│        radius (float): distance from origin to vertices (major), or
│            optionally from the origin to side (minor) with major_radius = False
│        side_count (int): number of polygon sides
│        major_radius (bool): If True the radius is the major radius, else the
│            radius is the minor radius (also known as inscribed radius).
⋮...
│    def __init__(
│        self,
│        radius: float,
│        side_count: int,
│        major_radius: bool = True,
│        rotation: float = 0,
│        align: tuple[Align, Align] = (Align.CENTER, Align.CENTER),
│        mode: Mode = Mode.ADD,
⋮...
│class SlotArc(BaseSketchObject):
│    """Sketch Object: Arc Slot
│
│    Add slot(s) following an arc to sketch.
│
│    Args:
│        arc (Union[Edge, Wire]): center line of slot
│        height (float): diameter of end circles
│        rotation (float, optional): angles to rotate objects. Defaults to 0.
│        mode (Mode, optional): combination mode. Defaults to Mode.ADD.
⋮...
│    def __init__(
│        self,
│        arc: Union[Edge, Wire],
│        height: float,
│        rotation: float = 0,
│        mode: Mode = Mode.ADD,
⋮...
│class SlotCenterPoint(BaseSketchObject):
│    """Sketch Object: Center Point Slot
│
│    Add a slot(s) defined by the center of the slot and the center of one of the
│    circular arcs at the end. The other end will be generated to create a symmetric
│    slot.
│
│    Args:
│        center (VectorLike): slot center point
│        point (VectorLike): slot center of arc point
│        height (float): diameter of end circles
⋮...
│    def __init__(
│        self,
│        center: VectorLike,
│        point: VectorLike,
│        height: float,
│        rotation: float = 0,
│        mode: Mode = Mode.ADD,
⋮...
│class SlotCenterToCenter(BaseSketchObject):
│    """Sketch Object: Center to Center points Slot
│
│    Add slot(s) defined by the distance between the center of the two
│    end arcs.
│
│    Args:
│        center_separation (float): distance between two arc centers
│        height (float): diameter of end circles
│        rotation (float, optional): angles to rotate objects. Defaults to 0.
│        mode (Mode, optional): combination mode. Defaults to Mode.ADD.
⋮...
│    def __init__(
│        self,
│        center_separation: float,
│        height: float,
│        rotation: float = 0,
│        mode: Mode = Mode.ADD,
⋮...
│class SlotOverall(BaseSketchObject):
│    """Sketch Object: Center to Center points Slot
│
│    Add slot(s) defined by the overall with of the slot.
│
│    Args:
│        width (float): overall width of the slot
│        height (float): diameter of end circles
│        rotation (float, optional): angles to rotate objects. Defaults to 0.
│        align (Union[Align, tuple[Align, Align]], optional): align min, center, or max of object.
│            Defaults to (Align.CENTER, Align.CENTER).
⋮...
│    def __init__(
│        self,
│        width: float,
│        height: float,
│        rotation: float = 0,
│        align: Union[Align, tuple[Align, Align]] = (Align.CENTER, Align.CENTER),
│        mode: Mode = Mode.ADD,
⋮...
│class Text(BaseSketchObject):
│    """Sketch Object: Text
│
│    Add text(s) to the sketch.
│
│    Args:
│        txt (str): text to be rendered
│        font_size (float): size of the font in model units
│        font (str, optional): font name. Defaults to "Arial".
│        font_path (str, optional): system path to font library. Defaults to None.
│        font_style (Font_Style, optional): style. Defaults to Font_Style.REGULAR.
⋮...
│    def __init__(
│        self,
│        txt: str,
│        font_size: float,
│        font: str = "Arial",
│        font_path: str = None,
│        font_style: FontStyle = FontStyle.REGULAR,
│        align: Union[Align, tuple[Align, Align]] = (Align.CENTER, Align.CENTER),
│        path: Union[Edge, Wire] = None,
│        position_on_path: float = 0.0,
⋮...
│class Trapezoid(BaseSketchObject):
│    """Sketch Object: Trapezoid
│
│    Add trapezoid(s) to the sketch.
│
│    Args:
│        width (float): horizontal width
│        height (float): vertical height
│        left_side_angle (float): bottom left interior angle
│        right_side_angle (float, optional): bottom right interior angle. If not provided,
│            the trapezoid will be symmetric. Defaults to None.
⋮...
│    def __init__(
│        self,
│        width: float,
│        height: float,
│        left_side_angle: float,
│        right_side_angle: float = None,
│        rotation: float = 0,
│        align: Union[Align, tuple[Align, Align]] = (Align.CENTER, Align.CENTER),
│        mode: Mode = Mode.ADD,
⋮...
│class Triangle(BaseSketchObject):
│    """Sketch Object: Triangle
│
│    Add any triangle to the sketch by specifying the length of any side and any
│    two other side lengths or interior angles. Note that the interior angles are
│    opposite the side with the same designation (i.e. side 'a' is opposite angle 'A').
│
│    Args:
│        a (float, optional): side 'a' length. Defaults to None.
│        b (float, optional): side 'b' length. Defaults to None.
│        c (float, optional): side 'c' length. Defaults to None.
⋮...
│    def __init__(
│        self,
│        *,
│        a: float = None,
│        b: float = None,
│        c: float = None,
│        A: float = None,
│        B: float = None,
│        C: float = None,
│        align: Union[None, Align, tuple[Align, Align]] = None,
⋮...

src/build123d/topology.py:
⋮...
│class Shape(NodeMixin):
│    """Shape
│
│    Base class for all CAD objects such as Edge, Face, Solid, etc.
│
│    Args:
│        obj (TopoDS_Shape, optional): OCCT object. Defaults to None.
│        label (str, optional): Defaults to ''.
│        color (Color, optional): Defaults to None.
│        parent (Compound, optional): assembly parent. Defaults to None.
│
⋮...
│    def __init__(
│        self,
│        obj: TopoDS_Shape = None,
│        label: str = "",
│        color: Color = None,
│        parent: Compound = None,
⋮...
│    class _DisplayNode(NodeMixin):
│        """Used to create anytree structures from TopoDS_Shapes"""
│
│        def __init__(
│            self,
│            label: str = "",
│            address: int = None,
│            position: Union[Vector, Location] = None,
│            parent: Shape._DisplayNode = None,
⋮...
│class ShapeList(list[T]):
⋮...
│class GroupBy(Generic[T, K]):
│    """Result of a Shape.groupby operation. Groups can be accessed by index or key"""
│
│    def __init__(
│        self,
│        key_f: Callable[[T], K],
│        shapelist: Iterable[T],
│        *,
│        reverse: bool = False,
⋮...
│class Compound(Mixin3D, Shape):
│    """A Compound in build123d is a topological entity representing a collection of
│    geometric shapes grouped together within a single structure. It serves as a
│    container for organizing diverse shapes like edges, faces, or solids. This
│    hierarchical arrangement facilitates the construction of complex models by
│    combining simpler shapes. Compound plays a pivotal role in managing the
│    composition and structure of intricate 3D models in computer-aided design
│    (CAD) applications, allowing engineers and designers to work with assemblies
⋮...
│    @overload
│    def __init__(
│        self,
│        obj: TopoDS_Shape,
│        label: str = "",
│        color: Color = None,
│        material: str = "",
│        joints: dict[str, Joint] = None,
│        parent: Compound = None,
│        children: Iterable[Shape] = None,
⋮...
│    @overload
│    def __init__(
│        self,
│        shapes: Iterable[Shape],
│        label: str = "",
│        color: Color = None,
│        material: str = "",
│        joints: dict[str, Joint] = None,
│        parent: Compound = None,
│        children: Iterable[Shape] = None,
⋮...
│    def __init__(self, *args, **kwargs):
⋮...
│class Face(Shape):
│    """A Face in build123d represents a 3D bounded surface within the topological data
│    structure. It encapsulates geometric information, defining a face of a 3D shape.
│    These faces are integral components of complex structures, such as solids and
│    shells. Face enables precise modeling and manipulation of surfaces, supporting
⋮...
│    @overload
│    def __init__(
│        self,
│        obj: TopoDS_Shape,
│        label: str = "",
│        color: Color = None,
│        parent: Compound = None,
⋮...
│    @overload
│    def __init__(
│        self,
│        outer_wire: Wire,
│        inner_wires: Iterable[Wire] = None,
│        label: str = "",
│        color: Color = None,
│        parent: Compound = None,
⋮...
│    def __init__(self, *args, **kwargs):
⋮...
│    def project_to_shape_alt(
│        self, target_object: Shape, direction: VectorLike
│    ) -> Union[None, Face, Compound]:
│        """project_to_shape_alt
│
│        Return the Faces contained within the first projection of self onto
│        the target.
│
│        Args:
│            target_object (Shape): Object to project onto
│            direction (VectorLike): projection direction
│
│        Returns:
⋮...
│        def get(los: TopTools_ListOfShape, shape_cls) -> list:
⋮...
│class Shell(Shape):
│    """A Shell is a fundamental component in build123d's topological data structure
│    representing a connected set of faces forming a closed surface in 3D space. As
│    part of a geometric model, it defines a watertight enclosure, commonly encountered
│    in solid modeling. Shells group faces in a coherent manner, playing a crucial role
│    in representing complex shapes with voids and surfaces. This hierarchical structure
│    allows for efficient handling of surfaces within a model, supporting various
⋮...
│    @overload
│    def __init__(
│        self,
│        obj: TopoDS_Shape,
│        label: str = "",
│        color: Color = None,
│        parent: Compound = None,
⋮...
│    @overload
│    def __init__(
│        self,
│        face: Face,
│        label: str = "",
│        color: Color = None,
│        parent: Compound = None,
⋮...
│    @overload
│    def __init__(
│        self,
│        faces: Iterable[Face],
│        label: str = "",
│        color: Color = None,
│        parent: Compound = None,
⋮...
│    def __init__(self, *args, **kwargs):
⋮...
│class Solid(Mixin3D, Shape):
│    """A Solid in build123d represents a three-dimensional solid geometry
│    in a topological structure. A solid is a closed and bounded volume, enclosing
│    a region in 3D space. It comprises faces, edges, and vertices connected in a
│    well-defined manner. Solid modeling operations, such as Boolean
│    operations (union, intersection, and difference), are often performed on
⋮...
│    @overload
│    def __init__(
│        self,
│        obj: TopoDS_Shape,
│        label: str = "",
│        color: Color = None,
│        material: str = "",
│        joints: dict[str, Joint] = None,
│        parent: Compound = None,
⋮...
│    @overload
│    def __init__(
│        self,
│        shell: Shell,
│        label: str = "",
│        color: Color = None,
│        material: str = "",
│        joints: dict[str, Joint] = None,
│        parent: Compound = None,
⋮...
│    def __init__(self, *args, **kwargs):
⋮...
│class Vertex(Shape):
│    """A Vertex in build123d represents a zero-dimensional point in the topological
│    data structure. It marks the endpoints of edges within a 3D model, defining precise
│    locations in space. Vertices play a crucial role in defining the geometry of objects
│    and the connectivity between edges, facilitating accurate representation and
│    manipulation of 3D shapes. They hold coordinate information and are essential
⋮...
│    @overload
│    def __init__(self):  # pragma: no cover
⋮...
│    @overload
│    def __init__(self, v: TopoDS_Vertex):  # pragma: no cover
⋮...
│    @overload
│    def __init__(self, X: float, Y: float, Z: float):  # pragma: no cover
⋮...
│    @overload
│    def __init__(self, v: Iterable[float]):
⋮...
│    @overload
│    def __init__(self, v: tuple[float]):
⋮...
│    def __init__(self, *args, **kwargs):
⋮...
│    def to_tuple(self) -> tuple[float, float, float]:
⋮...
│class Wire(Mixin1D, Shape):
│    """A Wire in build123d is a topological entity representing a connected sequence
│    of edges forming a continuous curve or path in 3D space. Wires are essential
│    components in modeling complex objects, defining boundaries for surfaces or
│    solids. They store information about the connectivity and order of edges,
⋮...
│    @overload
│    def __init__(
│        self,
│        obj: TopoDS_Shape,
│        label: str = "",
│        color: Color = None,
│        parent: Compound = None,
⋮...
│    @overload
│    def __init__(
│        self,
│        edge: Edge,
│        label: str = "",
│        color: Color = None,
│        parent: Compound = None,
⋮...
│    @overload
│    def __init__(
│        self,
│        wire: Wire,
│        label: str = "",
│        color: Color = None,
│        parent: Compound = None,
⋮...
│    @overload
│    def __init__(
│        self,
│        wire: Curve,
│        label: str = "",
│        color: Color = None,
│        parent: Compound = None,
⋮...
│    @overload
│    def __init__(
│        self,
│        edges: Iterable[Edge],
│        sequenced: bool = False,
│        label: str = "",
│        color: Color = None,
│        parent: Compound = None,
⋮...
│    def __init__(self, *args, **kwargs):
⋮...
│class Joint(ABC):
│    """Joint
│
│    Abstract Base Joint class - used to join two components together
│
│    Args:
│        parent (Union[Solid, Compound]): object that joint to bound to
│
│    Attributes:
│        label (str): user assigned label
│        parent (Shape): object joint is bound to
⋮...
│    def __init__(self, label: str, parent: Union[Solid, Compound]):
⋮...

