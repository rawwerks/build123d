Aider v0.37.0
Models: gpt-4o with diff edit format, weak model gpt-3.5-turbo
Git repo: .git with 27 files
Repo-map: using 2048 tokens
Here are summaries of some files present in my git repository.
Do not propose changes to these files, treat them as *read-only*.
If you need to edit any of these files, ask me to *add them to the chat* first.

src/build123d/__init__.py

src/build123d/_dev/__init__.py

src/build123d/_dev/scm_version.py

src/build123d/build_common.py:
⋮...
│def _is_point(obj):
⋮...
│def flatten_sequence(*obj: T) -> list[Any]:
⋮...
│class Builder(ABC):
│    """Builder
│
│    Base class for the build123d Builders.
│
│    Args:
│        workplanes: sequence of Union[Face, Plane, Location]: set plane(s) to work on
│        mode (Mode, optional): combination mode. Defaults to Mode.ADD.
│
│    Attributes:
│        mode (Mode): builder's combination mode
⋮...
│    @property
│    def new_edges(self) -> ShapeList[Edge]:
⋮...
│    def __init__(
│        self,
│        *workplanes: Union[Face, Plane, Location],
│        mode: Mode = Mode.ADD,
⋮...
│    def __enter__(self):
⋮...
│    def _exit_extras(self):
⋮...
│    def __exit__(self, exception_type, exception_value, traceback):
⋮...
│    @abstractmethod
│    def _add_to_pending(self, *objects: Union[Edge, Face], face_plane: Plane = None):
⋮...
│    @classmethod
│    def _get_context(cls, caller: Union[Builder, str] = None, log: bool = True) -> Self:
⋮...
│    def _add_to_context(
│        self,
│        *objects: Union[Edge, Wire, Face, Solid, Compound],
│        faces_to_pending: bool = True,
│        clean: bool = True,
│        mode: Mode = Mode.ADD,
⋮...
│    def vertices(self, select: Select = Select.ALL) -> ShapeList[Vertex]:
⋮...
│    def edges(self, select: Select = Select.ALL) -> ShapeList[Edge]:
⋮...
│    def edge(self, select: Select = Select.ALL) -> Edge:
⋮...
│    def wires(self, select: Select = Select.ALL) -> ShapeList[Wire]:
⋮...
│    def faces(self, select: Select = Select.ALL) -> ShapeList[Face]:
⋮...
│    def face(self, select: Select = Select.ALL) -> Face:
⋮...
│    def solids(self, select: Select = Select.ALL) -> ShapeList[Solid]:
⋮...
│    def _shapes(self, obj_type: Union[Vertex, Edge, Face, Solid] = None) -> ShapeList:
⋮...
│    def validate_inputs(
│        self, validating_class, objects: Union[Shape, Iterable[Shape]] = None
⋮...
│    def _invalid_combine(self):
⋮...
│def validate_inputs(
│    context: Builder, validating_class, objects: Iterable[Shape] = None
⋮...
│class LocationList:
│    """Location Context
│
│    A stateful context of active locations. At least one must be active
│    at all time. Note that local locations are stored and global locations
│    are returned as a property of the local locations and the currently
│    active workplanes.
│
│    Args:
│        locations (list[Location]): list of locations to add to the context
│
⋮...
│    @property
│    def locations(self) -> list[Location]:
⋮...
│    def __init__(self, locations: list[Location]):
⋮...
│    def __enter__(self):
⋮...
│    def __exit__(self, exception_type, exception_value, traceback):
⋮...
│    @classmethod
│    def _get_context(cls):
⋮...
│class HexLocations(LocationList):
│    """Location Context: Hex Array
│
│    Creates a context of hexagon array of locations for Part or Sketch. When creating
│    hex locations for an array of circles, set `apothem` to the radius of the circle
│    plus one half the spacing between the circles.
│
│    Args:
│        apothem (float): radius of the inscribed circle
│        xCount (int): number of points ( > 0 )
│        yCount (int): number of points ( > 0 )
⋮...
│    def __init__(
│        self,
│        apothem: float,
│        x_count: int,
│        y_count: int,
│        align: Union[Align, tuple[Align, Align]] = (Align.CENTER, Align.CENTER),
⋮...
│class PolarLocations(LocationList):
│    """Location Context: Polar Array
│
│    Creates a context of polar array of locations for Part or Sketch
│
│    Args:
│        radius (float): array radius
│        count (int): Number of points to push
│        start_angle (float, optional): angle to first point from +ve X axis. Defaults to 0.0.
│        angular_range (float, optional): magnitude of array from start angle. Defaults to 360.0.
│        rotate (bool, optional): Align locations with arc tangents. Defaults to True.
⋮...
│    def __init__(
│        self,
│        radius: float,
│        count: int,
│        start_angle: float = 0.0,
│        angular_range: float = 360.0,
│        rotate: bool = True,
│        endpoint: bool = False,
⋮...
│class Locations(LocationList):
│    """Location Context: Push Points
│
│    Creates a context of locations for Part or Sketch
│
│    Args:
│        pts (Union[VectorLike, Vertex, Location, Face, Plane, Axis] or iterable of same):
│            sequence of points to push
│
│    Attributes:
│        local_locations (list{Location}): locations relative to workplane
│
⋮...
│    def __init__(
│        self,
│        *pts: Union[
│            VectorLike,
│            Vertex,
│            Location,
│            Face,
│            Plane,
│            Axis,
│            Iterable[VectorLike, Vertex, Location, Face, Plane, Axis],
⋮...
│    @staticmethod
│    def _move_to_existing(local_locations: list[Location]) -> list[Location]:
⋮...
│class GridLocations(LocationList):
│    """Location Context: Rectangular Array
│
│    Creates a context of rectangular array of locations for Part or Sketch
│
│    Args:
│        x_spacing (float): horizontal spacing
│        y_spacing (float): vertical spacing
│        x_count (int): number of horizontal points
│        y_count (int): number of vertical points
│        align (Union[Align, tuple[Align, Align]], optional): align min, center, or max of object.
⋮...
│    def __init__(
│        self,
│        x_spacing: float,
│        y_spacing: float,
│        x_count: int,
│        y_count: int,
│        align: Union[Align, tuple[Align, Align]] = (Align.CENTER, Align.CENTER),
⋮...
│class WorkplaneList:
│    """Workplane Context
│
│    A stateful context of active workplanes. At least one must be active
│    at all time.
│
│    Args:
│        workplanes (sequence of Union[Face, Plane, Location]): objects to become planes
│
│    Attributes:
│        workplanes (list[Plane]): list of workplanes
│
⋮...
│    def __init__(self, *workplanes: Union[Face, Plane, Location]):
⋮...
│    @staticmethod
│    def _convert_to_planes(objs: Iterable[Union[Face, Plane, Location]]) -> list[Plane]:
⋮...
│    def __enter__(self):
⋮...
│    def __exit__(self, exception_type, exception_value, traceback):
⋮...
│    @classmethod
│    def _get_context(cls):
⋮...
│    @classmethod
│    def localize(cls, *points: VectorLike) -> Union[list[Vector], Vector]:
⋮...
│def __gen_context_component_getter(
│    func: Callable[Concatenate[Builder, P], T]
⋮...
│def _vector_add_sub_wrapper(original_op: Callable[[Vector, VectorLike], Vector]):
⋮...

src/build123d/build_enums.py

src/build123d/build_line.py:
⋮...
│class BuildLine(Builder):
│    """BuildLine
│
│    The BuildLine class is a subclass of Builder for building lines (objects
│    with length but not area or volume). It has an _obj property that returns
│    the current line being built. The class overrides the faces and solids methods
│    of Builder since they don't apply to lines.
│
│    BuildLine only works with a single workplane which is used to convert tuples
│    as inputs to global coordinates. For example:
│
⋮...
│    def __init__(
│        self,
│        workplane: Union[Face, Plane, Location] = Plane.XY,
│        mode: Mode = Mode.ADD,
⋮...
│    def __exit__(self, exception_type, exception_value, traceback):
⋮...
│    def faces(self, *args):
⋮...
│    def face(self, *args):
⋮...
│    def solids(self, *args):
⋮...
│    def _add_to_pending(self, *objects: Union[Edge, Face], face_plane: Plane = None):
⋮...

src/build123d/build_part.py:
⋮...
│class BuildPart(Builder):
│    """BuildPart
│
│    The BuildPart class is another subclass of Builder for building parts
│    (objects with the property of volume) from sketches or 3D objects.
│    It has an _obj property that returns the current part being built, and
│    several pending lists for storing faces, edges, and planes that will be
│    integrated into the final part later. The class overrides the _add_to_pending
│    method of Builder.
│
│    Args:
⋮...
│    def __init__(
│        self,
│        *workplanes: Union[Face, Plane, Location],
│        mode: Mode = Mode.ADD,
⋮...
│    def _add_to_pending(self, *objects: Union[Edge, Face], face_plane: Plane = None):
⋮...
│    def _exit_extras(self):
⋮...

src/build123d/build_sketch.py:
⋮...
│class BuildSketch(Builder):
│    """BuildSketch
│
│    The BuildSketch class is a subclass of Builder for building planar 2D
│    sketches (objects with area but not volume) from faces or lines.
│    It has an _obj property that returns the current sketch being built.
│    The sketch property consists of the sketch(es) applied to the input
│    workplanes while the sketch_local attribute is the sketch constructed
│    on Plane.XY. The class overrides the solids method of Builder since
│    they don't apply to lines.
│
⋮...
│    def __init__(
│        self,
│        *workplanes: Union[Face, Plane, Location],
│        mode: Mode = Mode.ADD,
⋮...
│    def solids(self, *args):
⋮...
│    def _add_to_pending(self, *objects: Edge, face_plane: Plane = None):
⋮...

src/build123d/drafting.py:
⋮...
│class ArrowHead(BaseSketchObject):
│    """Sketch Object: ArrowHead
│
│    Args:
│        size (float): tip to tail length
│        head_type (HeadType, optional): arrow head shape. Defaults to HeadType.CURVED.
│        rotation (float, optional): rotation in degrees. Defaults to 0.
│        mode (Mode, optional): combination mode. Defaults to Mode.ADD.
⋮...
│    def __init__(
│        self,
│        size: float,
│        head_type: HeadType = HeadType.CURVED,
│        rotation: float = 0,
│        mode: Mode = Mode.ADD,
⋮...
│class Arrow(BaseSketchObject):
│    """Sketch Object: Arrow with shaft
│
│    Args:
│        arrow_size (float): arrow head tip to tail length
│        shaft_path (Union[Edge, Wire]): line describing the shaft shape
│        shaft_width (float): line width of shaft
│        head_at_start (bool, optional): Defaults to True.
│        head_type (HeadType, optional): arrow head shape. Defaults to HeadType.CURVED.
│        mode (Mode, optional): _description_. Defaults to Mode.ADD.
⋮...
│    def __init__(
│        self,
│        arrow_size: float,
│        shaft_path: Union[Edge, Wire],
│        shaft_width: float,
│        head_at_start: bool = True,
│        head_type: HeadType = HeadType.CURVED,
│        mode: Mode = Mode.ADD,
⋮...
│@dataclass
│class Draft:
│    """Draft
│
│    Documenting build123d designs with dimension and extension lines as well as callouts.
│
│
│    Args:
│        font_size (float): size of the text in dimension lines and callouts. Defaults to 5.0.
│        font (str): font to use for text. Defaults to "Arial".
│        font_style: text style. Defaults to FontStyle.REGULAR.
│        head_type (HeadType, optional): arrow head shape. Defaults to HeadType.CURVED.
⋮...
│    def _round_to_str(self, number: float) -> str:
⋮...
│    def _number_with_units(
│        self,
│        number: float,
│        tolerance: Union[float, tuple[float, float]] = None,
│        display_units: Optional[bool] = None,
│    ) -> str:
│        """Convert a raw number to a unit of measurement string based on the class settings"""
│
│        def simplify_fraction(numerator: int, denominator: int) -> tuple[int, int]:
⋮...
│    @staticmethod
│    def _process_path(path: PathDescriptor) -> Union[Edge, Wire]:
⋮...
│    def _label_to_str(
│        self,
│        label: str,
│        line_wire: Wire,
│        label_angle: bool,
│        tolerance: Optional[Union[float, tuple[float, float]]],
⋮...
│    @staticmethod
│    def _sketch_location(
│        path: Union[Edge, Wire], u_value: float, flip: bool = False
⋮...
│class DimensionLine(BaseSketchObject):
│    """Sketch Object: DimensionLine
│
│    Create a dimension line typically for internal measurements.
│    Typically used for (but not restricted to) inside dimensions, a dimension line often
│    as arrows on either side of a dimension or label.
│
│    There are three options depending on the size of the text and length
│    of the dimension line:
│    Type 1) The label and arrows fit within the length of the path
│    Type 2) The text fit within the path and the arrows go outside
⋮...
│    def __init__(
│        self,
│        path: PathDescriptor,
│        draft: Draft = None,
│        sketch: Sketch = None,
│        label: str = None,
│        arrows: tuple[bool, bool] = (True, True),
│        tolerance: Union[float, tuple[float, float]] = None,
│        label_angle: bool = False,
│        mode: Mode = Mode.ADD,
⋮...
│class ExtensionLine(BaseSketchObject):
│    """Sketch Object: Extension Line
│
│    Create a dimension line with two lines extending outward from the part to dimension.
│    Typically used for (but not restricted to) outside dimensions, with a pair of lines
│    extending from the edge of a part to a dimension line.
│
│    Args:
│        border (PathDescriptor): a very general type of input defining the object to
│            be dimensioned. Typically this value would be extracted from the part but is
│            not restricted to this use.
⋮...
│    def __init__(
│        self,
│        border: PathDescriptor,
│        offset: float,
│        draft: Draft,
│        sketch: Sketch = None,
│        label: str = None,
│        arrows: tuple[bool, bool] = (True, True),
│        tolerance: Union[float, tuple[float, float]] = None,
│        label_angle: bool = False,
⋮...
│class TechnicalDrawing(BaseSketchObject):
│    """Sketch Object: TechnicalDrawing
│
│    The border of a technical drawing with external frame and text box.
│
│    Args:
│        designed_by (str, optional): Defaults to "build123d".
│        design_date (date, optional): Defaults to date.today().
│        page_size (PageSize, optional): Defaults to PageSize.A4.
│        title (str, optional): drawing title. Defaults to "Title".
│        sub_title (str, optional): drawing sub title. Defaults to "Sub Title".
⋮...
│    def __init__(
│        self,
│        designed_by: str = "build123d",
│        design_date: date = date.today(),
│        page_size: PageSize = PageSize.A4,
│        title: str = "Title",
│        sub_title: str = "Sub Title",
│        drawing_number: str = "B3D-1",
│        sheet_number: int = None,
│        drawing_scale: float = 1.0,
⋮...

src/build123d/exporters.py:
⋮...
│class Drawing:
│    """A base drawing object"""
│
│    def __init__(
│        self,
│        shape: Shape,
│        *,
│        look_at: VectorLike = None,
│        look_from: VectorLike = (1, -1, 1),
│        look_up: VectorLike = (0, 0, 1),
│        with_hidden: bool = True,
│        focus: Union[float, None] = None,
⋮...
│def ansi_pattern(*args):
⋮...
│def iso_pattern(*args):
⋮...
│def unit_conversion_scale(from_unit: Unit, to_unit: Unit) -> float:
⋮...
│class ExportDXF(Export2D):
│    """
│    The ExportDXF class provides functionality for exporting 2D shapes to DXF
│    (Drawing Exchange Format) format. DXF is a widely used file format for
│    exchanging CAD (Computer-Aided Design) data between different software
│    applications.
│
│
│    Args:
│        version (str, optional): The DXF version to use for the output file.
│            Defaults to ezdxf.DXF2013.
⋮...
│    def __init__(
│        self,
│        version: str = ezdxf.DXF2013,
│        unit: Unit = Unit.MM,
│        color: Optional[ColorIndex] = None,
│        line_weight: Optional[float] = None,
│        line_type: Optional[LineType] = None,
⋮...
│    def add_layer(
│        self,
│        name: str,
│        *,
│        color: Optional[ColorIndex] = None,
│        line_weight: Optional[float] = None,
│        line_type: Optional[LineType] = None,
⋮...
│    def _linetype(self, line_type: LineType) -> str:
⋮...
│    def _add_single_shape(self, shape: Shape, layer: str = ""):
⋮...
│    def write(self, file_name: str):
⋮...
│    def _convert_point(self, pt: Union[gp_XYZ, gp_Pnt, gp_Vec, Vector]) -> Vec2:
⋮...
│    def _convert_bspline(self, edge: Edge, attribs):
⋮...
│    def _convert_edge(self, edge: Edge, attribs: dict):
⋮...
│class ExportSVG(Export2D):
│    """ExportSVG
│
│    SVG file export functionality.
│
│    The ExportSVG class provides functionality for exporting 2D shapes to SVG
│    (Scalable Vector Graphics) format. SVG is a widely used vector graphics format
│    that is supported by web browsers and various graphic editors.
│
│    Args:
│        unit (Unit, optional): The unit used for the exported SVG. It should be one of
⋮...
│    class _Layer:
│        def __init__(
│            self,
│            name: str,
│            fill_color: Union[ColorIndex, RGB, Color, None],
│            line_color: Union[ColorIndex, RGB, Color, None],
│            line_weight: float,
│            line_type: LineType,
│        ):
│            def convert_color(
│                c: Union[ColorIndex, RGB, Color, None]
⋮...
│    def __init__(
│        self,
│        unit: Unit = Unit.MM,
│        scale: float = 1,
│        margin: float = 0,
│        fit_to_stroke: bool = True,
│        precision: int = 6,
│        fill_color: Union[ColorIndex, RGB, Color, None] = None,
│        line_color: Union[ColorIndex, RGB, Color, None] = Export2D.DEFAULT_COLOR_INDEX,
│        line_weight: float = Export2D.DEFAULT_LINE_WEIGHT,  # in millimeters
⋮...
│    def add_layer(
│        self,
│        name: str,
│        *,
│        fill_color: Union[ColorIndex, RGB, Color, None] = None,
│        line_color: Union[ColorIndex, RGB, Color, None] = Export2D.DEFAULT_COLOR_INDEX,
│        line_weight: float = Export2D.DEFAULT_LINE_WEIGHT,  # in millimeters
│        line_type: LineType = Export2D.DEFAULT_LINE_TYPE,
⋮...
│    def _add_single_shape(self, shape: Shape, layer: _Layer, reverse_wires: bool):
⋮...
│    @staticmethod
│    def _wire_edges(wire: Wire, reverse: bool) -> List[Edge]:
⋮...
│    def _wire_segments(self, wire: Wire, reverse: bool) -> list[PathSegment]:
⋮...
│    def _wire_element(self, wire: Wire, reverse: bool) -> ET.Element:
⋮...
│    def _path_point(self, pt: Union[gp_Pnt, Vector]) -> complex:
⋮...
│    def _line_segment(self, edge: Edge, reverse: bool) -> PT.Line:
⋮...
│    def _circle_segments(self, edge: Edge, reverse: bool) -> list[PathSegment]:
⋮...
│    def _ellipse_segments(self, edge: Edge, reverse: bool) -> list[PathSegment]:
⋮...
│    def _bspline_segments(self, edge: Edge, reverse: bool) -> list[PathSegment]:
⋮...
│        edge = edge.to_splines()
│
⋮...
│        def make_segment(bezier: Geom_BezierCurve, reverse: bool) -> PathSegment:
⋮...
│    def _bspline_element(self, edge: Edge) -> ET.Element:
⋮...
│    def _edge_segments(self, edge: Edge, reverse: bool) -> list[PathSegment]:
⋮...
│    def _edge_element(self, edge: Edge) -> ET.Element:
⋮...
│    def _stroke_dasharray(self, layer: _Layer):
⋮...
│    def _group_for_layer(self, layer: _Layer, attribs: dict = None) -> ET.Element:
│
│        def _color_attribs(c: Color) -> Tuple[str, str]:
│            if c:
│                (r, g, b, a) = tuple(c)
│                (r, g, b, a) = (int(r * 255), int(g * 255), int(b * 255), round(a, 3))
│                rgb = f"rgb({r},{g},{b})"
│                opacity = f"{a}" if a < 1 else None
│                return (rgb, opacity)
⋮...
│    def write(self, path: str):
⋮...

src/build123d/exporters3d.py:
⋮...
│def _create_xde(to_export: Shape, unit: Unit = Unit.MM) -> TDocStd_Document:
⋮...

src/build123d/geometry.py:
⋮...
│class Vector:
│    """Create a 3-dimensional vector
│
│    Args:
│        x (float): x component
│        y (float): y component
│        z (float): z component
│        vec (Union[Vector, Sequence(float), gp_Vec, gp_Pnt, gp_Dir, gp_XYZ]): vector representation
│
│    Note that if no z value is provided it's assumed to be zero. If no values are provided
│    the returned Vector has the value of 0, 0, 0.
│
⋮...
│    @overload
│    def __init__(self, X: float, Y: float, Z: float):  # pragma: no cover
⋮...
│    @overload
│    def __init__(self, X: float, Y: float):  # pragma: no cover
⋮...
│    @overload
│    def __init__(self, v: Vector):  # pragma: no cover
⋮...
│    @overload
│    def __init__(self, v: Sequence[float]):  # pragma: no cover
⋮...
│    @overload
│    def __init__(self, v: Union[gp_Vec, gp_Pnt, gp_Dir, gp_XYZ]):  # pragma: no cover
⋮...
│    @overload
│    def __init__(self):  # pragma: no cover
⋮...
│    def __init__(self, *args, **kwargs):
⋮...
│    @property
│    def X(self) -> float:
⋮...
│    @X.setter
│    def X(self, value: float) -> None:
⋮...
│    @property
│    def Y(self) -> float:
⋮...
│    @Y.setter
│    def Y(self, value: float) -> None:
⋮...
│    @property
│    def Z(self) -> float:
⋮...
│    @Z.setter
│    def Z(self, value: float) -> None:
⋮...
│    def to_tuple(self) -> tuple[float, float, float]:
⋮...
│    def cross(self, vec: Vector) -> Vector:
⋮...
│    def dot(self, vec: Vector) -> float:
⋮...
│    def sub(self, vec: VectorLike) -> Vector:
⋮...
│    def add(self, vec: VectorLike) -> Vector:
⋮...
│    def multiply(self, scale: float) -> Vector:
⋮...
│    def normalized(self) -> Vector:
⋮...
│    def reverse(self) -> Vector:
⋮...
│    def center(self) -> Vector:
⋮...
│    def get_angle(self, vec: Vector) -> float:
⋮...
│    def get_signed_angle(self, vec: Vector, normal: Vector = None) -> float:
⋮...
│    def __eq__(self, other: Vector) -> bool:  # type: ignore[override]
⋮...
│    def to_pnt(self) -> gp_Pnt:
⋮...
│    def to_dir(self) -> gp_Dir:
⋮...
│    def transform(self, affine_transform: Matrix) -> Vector:
⋮...
│    def rotate(self, axis: Axis, angle: float) -> Vector:
⋮...
│class AxisMeta(type):
│    """Axis meta class to enable class properties"""
│
│    @property
│    def X(cls) -> Axis:
⋮...
│    @property
│    def Y(cls) -> Axis:
⋮...
│    @property
│    def Z(cls) -> Axis:
⋮...
│class Axis(metaclass=AxisMeta):
│    """Axis
│
│    Axis defined by point and direction
│
│    Args:
│        origin (VectorLike): start point
│        direction (VectorLike): direction
│        edge (Edge): origin & direction defined by start of edge
│
│    Attributes:
⋮...
│    @overload
│    def __init__(self, origin: VectorLike, direction: VectorLike):  # pragma: no cover
⋮...
│    @overload
│    def __init__(self, edge: "Edge"):  # pragma: no cover
⋮...
│    def __init__(self, *args, **kwargs):
⋮...
│    @classmethod
│    def from_occt(cls, axis: gp_Ax1) -> Axis:
⋮...
│    def __eq__(self, other: object) -> bool:
⋮...
│    def located(self, new_location: Location):
⋮...
│    def to_plane(self) -> Plane:
⋮...
│    def is_coaxial(
│        self,
│        other: Axis,
│        angular_tolerance: float = 1e-5,
│        linear_tolerance: float = 1e-5,
⋮...
│    def is_normal(self, other: Axis, angular_tolerance: float = 1e-5) -> bool:
⋮...
│    def is_opposite(self, other: Axis, angular_tolerance: float = 1e-5) -> bool:
⋮...
│    def is_parallel(self, other: Axis, angular_tolerance: float = 1e-5) -> bool:
⋮...
│    def reverse(self) -> Axis:
⋮...
│class BoundBox:
│    """A BoundingBox for a Shape"""
│
│    def __init__(self, bounding_box: Bnd_Box) -> None:
⋮...
│    def center(self) -> Vector:
⋮...
│    def add(
│        self,
│        obj: Union[tuple[float, float, float], Vector, BoundBox],
│        tol: float = None,
⋮...
│    @classmethod
│    def _from_topo_ds(
│        cls,
│        shape: TopoDS_Shape,
│        tolerance: float = None,
│        optimal: bool = True,
│        oriented: bool = False,
⋮...
│    def is_inside(self, second_box: BoundBox) -> bool:
⋮...
│    def to_align_offset(self, align: Tuple[float, float]) -> Tuple[float, float]:
⋮...
│class Color:
│    """
│    Color object based on OCCT Quantity_ColorRGBA.
│
│    Attributes:
│        wrapped (Quantity_ColorRGBA): the OCP color object
⋮...
│    @overload
│    def __init__(self, q_color: Quantity_ColorRGBA):
⋮...
│    @overload
│    def __init__(self, name: str, alpha: float = 1.0):
⋮...
│    @overload
│    def __init__(self, red: float, green: float, blue: float, alpha: float = 1.0):
⋮...
│    @overload
│    def __init__(self, color_code: int, alpha: int = 0xFF):
⋮...
│    def __init__(self, *args, **kwargs):
⋮...
│    def to_tuple(self):
⋮...
│class Location:
│    """Location in 3D space. Depending on usage can be absolute or relative.
│
│    This class wraps the TopLoc_Location class from OCCT. It can be used to move Shape
│    objects in both relative and absolute manner. It is the preferred type to locate objects
│    in build123d.
│
│    Attributes:
│        wrapped (TopLoc_Location): the OCP location object
│
⋮...
│    @overload
│    def __init__(self):  # pragma: no cover
⋮...
│    @overload
│    def __init__(self, location: Location):  # pragma: no cover
⋮...
│    @overload
│    def __init__(self, translation: VectorLike, angle: float = 0):  # pragma: no cover
⋮...
│    @overload
│    def __init__(
│        self, translation: VectorLike, rotation: RotationLike = None
⋮...
│    @overload
│    def __init__(
│        self,
│        translation: VectorLike,
│        rotation: RotationLike,
│        ordering: Union[Extrinsic, Intrinsic],
⋮...
│    @overload
│    def __init__(self, plane: Plane):  # pragma: no cover
⋮...
│    @overload
│    def __init__(self, plane: Plane, plane_offset: VectorLike):  # pragma: no cover
⋮...
│    @overload
│    def __init__(self, top_loc: TopLoc_Location):  # pragma: no cover
⋮...
│    @overload
│    def __init__(self, gp_trsf: gp_Trsf):  # pragma: no cover
⋮...
│    @overload
│    def __init__(
│        self, translation: VectorLike, direction: VectorLike, angle: float
⋮...
│    def __init__(self, *args):
⋮...
│    def inverse(self) -> Location:
⋮...
│    def __eq__(self, other: Location) -> bool:
⋮...
│    def to_axis(self) -> Axis:
⋮...
│    def to_tuple(self) -> tuple[tuple[float, float, float], tuple[float, float, float]]:
⋮...
│class Rotation(Location):
│    """Subclass of Location used only for object rotation
│
│    Attributes:
│        X (float): rotation in degrees about X axis
│        Y (float): rotation in degrees about Y axis
│        Z (float): rotation in degrees about Z axis
│        optionally specify rotation ordering with Intrinsic or Extrinsic enums, defaults to Intrins
│
⋮...
│    @overload
│    def __init__(
│        self,
│        rotation: RotationLike,
│        ordering: Union[Extrinsic, Intrinsic] == Intrinsic.XYZ,
⋮...
│    @overload
│    def __init__(
│        self,
│        X: float = 0,
│        Y: float = 0,
│        Z: float = 0,
│        ordering: Union[Extrinsic, Intrinsic] = Intrinsic.XYZ,
⋮...
│    def __init__(self, *args, **kwargs):
⋮...
│class Pos(Location):
│    """A position only sub-class of Location"""
│
│    @overload
│    def __init__(self, v: VectorLike):
⋮...
│    @overload
│    def __init__(self, v: Iterable):
⋮...
│    @overload
│    def __init__(self, X: float = 0, Y: float = 0, Z: float = 0):
⋮...
│    def __init__(self, *args, **kwargs):
⋮...
│class Matrix:
│    """A 3d , 4x4 transformation matrix.
│
│    Used to move geometry in space.
│
│    The provided "matrix" parameter may be None, a gp_GTrsf, or a nested list of
│    values.
│
│    If given a nested list, it is expected to be of the form:
│
│        [[m11, m12, m13, m14],
⋮...
│    @overload
│    def __init__(self) -> None:  # pragma: no cover
⋮...
│    @overload
│    def __init__(self, matrix: Union[gp_GTrsf, gp_Trsf]) -> None:  # pragma: no cover
⋮...
│    @overload
│    def __init__(self, matrix: Sequence[Sequence[float]]) -> None:  # pragma: no cover
⋮...
│    def __init__(self, matrix=None):
⋮...
│    def rotate(self, axis: Axis, angle: float):
⋮...
│    def inverse(self) -> Matrix:
⋮...
│    @overload
│    def multiply(self, other: Vector) -> Vector:  # pragma: no cover
⋮...
│    @overload
│    def multiply(self, other: Matrix) -> Matrix:  # pragma: no cover
⋮...
│    def multiply(self, other):
⋮...
│    def transposed_list(self) -> Sequence[float]:
⋮...
│    def __getitem__(self, row_col: tuple[int, int]) -> float:
⋮...
│class Plane(metaclass=PlaneMeta):
│    """Plane
│
│    A plane is positioned in space with a coordinate system such that the plane is defined by
│    the origin, x_dir (X direction), y_dir (Y direction), and z_dir (Z direction) of this coordinat
│    system, which is the "local coordinate system" of the plane. The z_dir is a vector normal to th
│    plane. The coordinate system is right-handed.
│
│    A plane allows the use of local 2D coordinates, which are later converted to
│    global, 3d coordinates when the operations are complete.
│
⋮...
│    @staticmethod
│    def get_topods_face_normal(face: TopoDS_Face) -> Vector:
⋮...
│    @overload
│    def __init__(self, gp_pln: gp_Pln):  # pragma: no cover
⋮...
│    @overload
│    def __init__(
│        self, face: "Face", x_dir: Optional[VectorLike] = None
⋮...
│    @overload
│    def __init__(self, location: Location):  # pragma: no cover
⋮...
│    @overload
│    def __init__(
│        self,
│        origin: VectorLike,
│        x_dir: VectorLike = None,
│        z_dir: VectorLike = (0, 0, 1),
⋮...
│    def __init__(self, *args, **kwargs):
│        # pylint: disable=too-many-locals,too-many-branches,too-many-statements
│        """Create a plane from either an OCCT gp_pln or coordinates"""
│
│        def optarg(kwargs, name, args, index, default):
⋮...
│    def _eq_iter(self, other: Plane):
⋮...
│    def __eq__(self, other: Plane):
⋮...
│    def reverse(self) -> Plane:
⋮...
│    def shift_origin(self, locator: Union[Axis, VectorLike, "Vertex"]) -> Plane:
⋮...
│    def rotated(
│        self,
│        rotation: VectorLike = (0, 0, 0),
│        ordering: Union[Extrinsic, Intrinsic] = None,
⋮...
│    def move(self, loc: Location) -> Plane:
⋮...
│    def _calc_transforms(self):
⋮...
│    def to_gp_ax2(self) -> gp_Ax2:
⋮...
│    def _to_from_local_coords(
│        self, obj: Union[VectorLike, Any, BoundBox], to_from: bool = True
⋮...
│    def to_local_coords(self, obj: Union[VectorLike, Any, BoundBox]):
⋮...
│    def from_local_coords(self, obj: Union[tuple, Vector, Any, BoundBox]):
⋮...
│    def contains(
│        self, obj: Union[VectorLike, Axis], tolerance: float = TOLERANCE
⋮...
│    def find_intersection(self, axis: Axis) -> Union[Vector, None]:
⋮...

src/build123d/importers.py:
⋮...
│def import_step(filename: str) -> Compound:
│    """import_step
│
│    Extract shapes from a STEP file and return them as a Compound object.
│
│    Args:
│        file_name (str): file path of STEP file to import
│
│    Raises:
│        ValueError: can't open file
│
⋮...
│    def get_name(label: TDF_Label) -> str:
⋮...
│    def get_color(shape: TopoDS_Shape) -> Quantity_ColorRGBA:
│
│        def get_col(obj: TopoDS_Shape) -> Quantity_ColorRGBA:
│            col = Quantity_ColorRGBA()
│            if (
│                color_tool.GetColor(obj, XCAFDoc_ColorCurv, col)
│                or color_tool.GetColor(obj, XCAFDoc_ColorGen, col)
│                or color_tool.GetColor(obj, XCAFDoc_ColorSurf, col)
│            ):
⋮...
│    def build_assembly(assembly: Compound) -> list[Shape]:
⋮...

src/build123d/joints.py:
⋮...
│class RigidJoint(Joint):
│    """RigidJoint
│
│    A rigid joint fixes two components to one another.
│
│    Args:
│        label (str): joint label
│        to_part (Union[Solid, Compound], optional): object to attach joint to
│        joint_location (Location): global location of joint
│
│    Attributes:
⋮...
│    def __init__(
│        self,
│        label: str,
│        to_part: Union[Solid, Compound] = None,
│        joint_location: Location = Location(),
⋮...
│    @overload
│    def relative_to(self, other: BallJoint, *, angles: RotationLike = None):
⋮...
│    @overload
│    def relative_to(
│        self, other: CylindricalJoint, *, position: float = None, angle: float = None
⋮...
│    @overload
│    def relative_to(self, other: LinearJoint, *, position: float = None):
⋮...
│    @overload
│    def relative_to(self, other: RevoluteJoint, *, angle: float = None):
⋮...
│    @overload
│    def relative_to(self, other: RigidJoint):
⋮...
│    def relative_to(self, other: Joint, **kwargs) -> Location:
⋮...
│class RevoluteJoint(Joint):
│    """RevoluteJoint
│
│    Component rotates around axis like a hinge.
│
│    Args:
│        label (str): joint label
│        to_part (Union[Solid, Compound], optional): object to attach joint to
│        axis (Axis): axis of rotation
│        angle_reference (VectorLike, optional): direction normal to axis defining where
│            angles will be measured from. Defaults to None.
⋮...
│    def __init__(
│        self,
│        label: str,
│        to_part: Union[Solid, Compound] = None,
│        axis: Axis = Axis.Z,
│        angle_reference: VectorLike = None,
│        angular_range: tuple[float, float] = (0, 360),
⋮...
│    def relative_to(
│        self, other: RigidJoint, *, angle: float = None
⋮...
│class LinearJoint(Joint):
│    """LinearJoint
│
│    Component moves along a single axis.
│
│    Args:
│        label (str): joint label
│        to_part (Union[Solid, Compound], optional): object to attach joint to
│        axis (Axis): axis of linear motion
│        range (tuple[float, float], optional): (min,max) position of joint.
│            Defaults to (0, inf).
│
⋮...
│    def __init__(
│        self,
│        label: str,
│        to_part: Union[Solid, Compound] = None,
│        axis: Axis = Axis.Z,
│        linear_range: tuple[float, float] = (0, inf),
⋮...
│    @overload
│    def relative_to(
│        self, other: RigidJoint, *, position: float = None
⋮...
│    @overload
│    def relative_to(
│        self, other: RevoluteJoint, *, position: float = None, angle: float = None
⋮...
│    def relative_to(self, other, **kwargs):  # pylint: disable=arguments-differ
⋮...
│class CylindricalJoint(Joint):
│    """CylindricalJoint
│
│    Component rotates around and moves along a single axis like a screw.
│
│    Args:
│        label (str): joint label
│        to_part (Union[Solid, Compound], optional): object to attach joint to
│        axis (Axis): axis of rotation and linear motion
│        angle_reference (VectorLike, optional): direction normal to axis defining where
│            angles will be measured from. Defaults to None.
⋮...
│    def __init__(
│        self,
│        label: str,
│        to_part: Union[Solid, Compound] = None,
│        axis: Axis = Axis.Z,
│        angle_reference: VectorLike = None,
│        linear_range: tuple[float, float] = (0, inf),
│        angular_range: tuple[float, float] = (0, 360),
⋮...
│    def relative_to(
│        self, other: RigidJoint, *, position: float = None, angle: float = None
⋮...
│class BallJoint(Joint):
│    """BallJoint
│
│    A component rotates around all 3 axes using a gimbal system (3 nested rotations).
│
│    Args:
│        label (str): joint label
│        to_part (Union[Solid, Compound], optional): object to attach joint to
│        joint_location (Location): global location of joint
│        angular_range
│            (tuple[ tuple[float, float], tuple[float, float], tuple[float, float] ], optional):
⋮...
│    def __init__(
│        self,
│        label: str,
│        to_part: Union[Solid, Compound] = None,
│        joint_location: Location = Location(),
│        angular_range: tuple[
│            tuple[float, float], tuple[float, float], tuple[float, float]
│        ] = ((0, 360), (0, 360), (0, 360)),
│        angle_reference: Plane = Plane.XY,
⋮...
│    def relative_to(
│        self, other: RigidJoint, *, angles: RotationLike = None
⋮...

src/build123d/jupyter_tools.py:
⋮...
│def to_vtkpoly_string(
│    shape: Any, tolerance: float = 1e-3, angular_tolerance: float = 0.1
⋮...
│def display(shape: Any) -> Javascript:
⋮...

src/build123d/mesher.py:
⋮...
│class Mesher:
│    """Mesher
│
│    Tool for exporting and importing meshed objects stored in 3MF or STL files.
│
│    Args:
│        unit (Unit, optional): model units. Defaults to Unit.MM.
⋮...
│    def __init__(self, unit: Unit = Unit.MM):
⋮...
│    def add_meta_data(
│        self,
│        name_space: str,
│        name: str,
│        value: str,
│        metadata_type: str,
│        must_preserve: bool,
⋮...
│    @staticmethod
│    def _mesh_shape(
│        ocp_mesh: Shape,
│        linear_deflection: float,
│        angular_deflection: float,
⋮...
│    @staticmethod
│    def _create_3mf_mesh(
│        ocp_mesh_vertices: list[tuple[float, float, float]],
│        triangles: list[list[int, int, int]],
⋮...
│    def _add_color(self, b3d_shape: Shape, mesh_3mf: Lib3MF.MeshObject):
⋮...
│    def _get_shape(self, mesh_3mf: Lib3MF.MeshObject) -> Shape:
⋮...
│    def read(self, file_name: str) -> list[Shape]:
⋮...
│    def write(self, file_name: str):
⋮...

src/build123d/objects_curve.py:
⋮...
│class BaseLineObject(Wire):
│    """BaseLineObject
│
│    Base class for all BuildLine objects
│
│    Args:
│        curve (Union[Edge,Wire]): edge to create
│        mode (Mode, optional): combination mode. Defaults to Mode.ADD.
⋮...
│    def __init__(
│        self,
│        curve: Union[Edge, Wire],
│        mode: Mode = Mode.ADD,
⋮...
│class Bezier(BaseLineObject):
│    """Line Object: Bezier Curve
│
│    Create a rational (with weights) or non-rational bezier curve.  The first and last
│    control points represent the start and end of the curve respectively.  If weights
│    are provided, there must be one provided for each control point.
│
│    Args:
│        cntl_pnts (sequence[VectorLike]): points defining the curve
│        weights (list[float], optional): control point weights list. Defaults to None.
│        mode (Mode, optional): combination mode. Defaults to Mode.ADD.
⋮...
│    def __init__(
│        self,
│        *cntl_pnts: VectorLike,
│        weights: list[float] = None,
│        mode: Mode = Mode.ADD,
⋮...
│class CenterArc(BaseLineObject):
│    """Line Object: Center Arc
│
│    Add center arc to the line.
│
│    Args:
│        center (VectorLike): center point of arc
│        radius (float): arc radius
│        start_angle (float): arc staring angle
│        arc_size (float): arc size
│        mode (Mode, optional): combination mode. Defaults to Mode.ADD.
⋮...
│    def __init__(
│        self,
│        center: VectorLike,
│        radius: float,
│        start_angle: float,
│        arc_size: float,
│        mode: Mode = Mode.ADD,
⋮...
│class DoubleTangentArc(BaseLineObject):
│    """Line Object: Double Tangent Arc
│
│    Create an arc defined by a point/tangent pair and another line which the other end
│    is tangent to.
│
│    Contains a solver.
│
│    Args:
│        pnt (VectorLike): starting point of tangent arc
│        tangent (VectorLike): tangent at starting point of tangent arc
⋮...
│    def __init__(
│        self,
│        pnt: VectorLike,
│        tangent: VectorLike,
│        other: Union[Curve, Edge, Wire],
│        keep: Keep = Keep.TOP,
│        mode: Mode = Mode.ADD,
│    ):
│        context: BuildLine = BuildLine._get_context(self)
⋮...
│        def func(radius, perpendicular_bisector):
⋮...
│class EllipticalStartArc(BaseLineObject):
│    """Line Object: Elliptical Start Arc
│
│    Makes an arc of an ellipse from the start point.
│
│    Args:
│        start (VectorLike): initial point of arc
│        end (VectorLike): final point of arc
│        x_radius (float): semi-major radius
│        y_radius (float): semi-minor radius
│        rotation (float, optional): the angle from the x-axis of the plane to the x-axis
⋮...
│    def __init__(
│        self,
│        start: VectorLike,
│        end: VectorLike,
│        x_radius: float,
│        y_radius: float,
│        rotation: float = 0.0,
│        large_arc: bool = False,
│        sweep_flag: bool = True,
│        plane: Plane = Plane.XY,
⋮...
│class EllipticalCenterArc(BaseLineObject):
│    """Line Object: Elliptical Center Arc
│
│    Makes an arc of an ellipse from a center point.
│
│    Args:
│        center (VectorLike): ellipse center
│        x_radius (float): x radius of the ellipse (along the x-axis of plane)
│        y_radius (float): y radius of the ellipse (along the y-axis of plane)
│        start_angle (float, optional): Defaults to 0.0.
│        end_angle (float, optional): Defaults to 90.0.
⋮...
│    def __init__(
│        self,
│        center: VectorLike,
│        x_radius: float,
│        y_radius: float,
│        start_angle: float = 0.0,
│        end_angle: float = 90.0,
│        rotation: float = 0.0,
│        angular_direction: AngularDirection = AngularDirection.COUNTER_CLOCKWISE,
│        mode: Mode = Mode.ADD,
⋮...
│class Helix(BaseLineObject):
│    """Line Object: Helix
│
│    Add a helix to the line.
│
│    Args:
│        pitch (float): distance between successive loops
│        height (float): helix size
│        radius (float): helix radius
│        center (VectorLike, optional): center point. Defaults to (0, 0, 0).
│        direction (VectorLike, optional): direction of central axis. Defaults to (0, 0, 1).
⋮...
│    def __init__(
│        self,
│        pitch: float,
│        height: float,
│        radius: float,
│        center: VectorLike = (0, 0, 0),
│        direction: VectorLike = (0, 0, 1),
│        cone_angle: float = 0,
│        lefthand: bool = False,
│        mode: Mode = Mode.ADD,
⋮...
│class FilletPolyline(BaseLineObject):
│    """Line Object: FilletPolyline
│
│    Add a sequence of straight lines defined by successive points that
│    are filleted to a given radius.
│
│    Args:
│        pts (Union[VectorLike, Iterable[VectorLike]]): sequence of two or more points
│        radius (float): radius of filleted corners
│        close (bool, optional): close by generating an extra Edge. Defaults to False.
│        mode (Mode, optional): combination mode. Defaults to Mode.ADD.
│
⋮...
│    def __init__(
│        self,
│        *pts: Union[VectorLike, Iterable[VectorLike]],
│        radius: float,
│        close: bool = False,
│        mode: Mode = Mode.ADD,
⋮...
│class JernArc(BaseLineObject):
│    """JernArc
│
│    Circular tangent arc with given radius and arc_size
│
│    Args:
│        start (VectorLike): start point
│        tangent (VectorLike): tangent at start point
│        radius (float): arc radius
│        arc_size (float): arc size in degrees (negative to change direction)
│        mode (Mode, optional): combination mode. Defaults to Mode.ADD.
│
⋮...
│    def __init__(
│        self,
│        start: VectorLike,
│        tangent: VectorLike,
│        radius: float,
│        arc_size: float,
│        mode: Mode = Mode.ADD,
⋮...
│class Line(BaseLineObject):
│    """Line Object: Line
│
│    Add a straight line defined by two end points.
│
│    Args:
│        pts (Union[VectorLike, Iterable[VectorLike]]): sequence of two points
│        mode (Mode, optional): combination mode. Defaults to Mode.ADD.
│
│    Raises:
│        ValueError: Two point not provided
⋮...
│    def __init__(
│        self, *pts: Union[VectorLike, Iterable[VectorLike]], mode: Mode = Mode.ADD
⋮...
│class IntersectingLine(BaseLineObject):
│    """Intersecting Line Object: Line
│
│    Add a straight line that intersects another line at a given parameter and angle.
│
│    Args:
│        start (VectorLike): start point
│        direction (VectorLike): direction to make line
│        other (Edge): stop at the intersection of other
│        mode (Mode, optional): combination mode. Defaults to Mode.ADD.
│
⋮...
│    def __init__(
│        self,
│        start: VectorLike,
│        direction: VectorLike,
│        other: Union[Curve, Edge, Wire],
│        mode: Mode = Mode.ADD,
⋮...
│class PolarLine(BaseLineObject):
│    """Line Object: Polar Line
│
│    Add line defined by a start point, length and angle.
│
│    Args:
│        start (VectorLike): start point
│        length (float): line length
│        angle (float): angle from the local "X" axis.
│        length_mode (LengthMode, optional): length value specifies a diagonal, horizontal
│            or vertical value. Defaults to LengthMode.DIAGONAL
⋮...
│    def __init__(
│        self,
│        start: VectorLike,
│        length: float,
│        angle: float = None,
│        direction: VectorLike = None,
│        length_mode: LengthMode = LengthMode.DIAGONAL,
│        mode: Mode = Mode.ADD,
⋮...
│class Polyline(BaseLineObject):
│    """Line Object: Polyline
│
│    Add a sequence of straight lines defined by successive point pairs.
│
│    Args:
│        pts (Union[VectorLike, Iterable[VectorLike]]): sequence of two or more points
│        close (bool, optional): close by generating an extra Edge. Defaults to False.
│        mode (Mode, optional): combination mode. Defaults to Mode.ADD.
│
│    Raises:
⋮...
│    def __init__(
│        self,
│        *pts: Union[VectorLike, Iterable[VectorLike]],
│        close: bool = False,
│        mode: Mode = Mode.ADD,
⋮...
│class RadiusArc(BaseLineObject):
│    """Line Object: Radius Arc
│
│    Add an arc defined by two end points and a radius
│
│    Args:
│        start_point (VectorLike): start
│        end_point (VectorLike): end
│        radius (float): radius
│        short_sagitta (bool): If True selects the short sagitta, else the
│            long sagitta crossing the center. Defaults to True.
⋮...
│    def __init__(
│        self,
│        start_point: VectorLike,
│        end_point: VectorLike,
│        radius: float,
│        short_sagitta: bool = True,
│        mode: Mode = Mode.ADD,
⋮...
│class SagittaArc(BaseLineObject):
│    """Line Object: Sagitta Arc
│
│    Add an arc defined by two points and the height of the arc (sagitta).
│
│    Args:
│        start_point (VectorLike): start
│        end_point (VectorLike): end
│        sagitta (float): arc height
│        mode (Mode, optional): combination mode. Defaults to Mode.ADD.
⋮...
│    def __init__(
│        self,
│        start_point: VectorLike,
│        end_point: VectorLike,
│        sagitta: float,
│        mode: Mode = Mode.ADD,
⋮...
│class Spline(BaseLineObject):
│    """Line Object: Spline
│
│    Add a spline through the provided points optionally constrained by tangents.
│
│    Args:
│        pts (Union[VectorLike, Iterable[VectorLike]]): sequence of two or more points
│        tangents (Iterable[VectorLike], optional): tangents at end points. Defaults to None.
│        tangent_scalars (Iterable[float], optional): change shape by amplifying tangent.
│            Defaults to None.
│        periodic (bool, optional): make the spline periodic. Defaults to False.
⋮...
│    def __init__(
│        self,
│        *pts: Union[VectorLike, Iterable[VectorLike]],
│        tangents: Iterable[VectorLike] = None,
│        tangent_scalars: Iterable[float] = None,
│        periodic: bool = False,
│        mode: Mode = Mode.ADD,
⋮...
│class TangentArc(BaseLineObject):
│    """Line Object: Tangent Arc
│
│    Add an arc defined by two points and a tangent.
│
│    Args:
│        pts (Union[VectorLike, Iterable[VectorLike]]): sequence of two points
│        tangent (VectorLike): tangent to constrain arc
│        tangent_from_first (bool, optional): apply tangent to first point. Note, applying
│            tangent to end point will flip the orientation of the arc. Defaults to True.
│        mode (Mode, optional): combination mode. Defaults to Mode.ADD.
│
⋮...
│    def __init__(
│        self,
│        *pts: Union[VectorLike, Iterable[VectorLike]],
│        tangent: VectorLike,
│        tangent_from_first: bool = True,
│        mode: Mode = Mode.ADD,
⋮...
│class ThreePointArc(BaseLineObject):
│    """Line Object: Three Point Arc
│
│    Add an arc generated by three points.
│
│    Args:
│        pts (Union[VectorLike, Iterable[VectorLike]]): sequence of three points
│        mode (Mode, optional): combination mode. Defaults to Mode.ADD.
│
│    Raises:
│        ValueError: Three points must be provided
⋮...
│    def __init__(
│        self, *pts: Union[VectorLike, Iterable[VectorLike]], mode: Mode = Mode.ADD
⋮...

src/build123d/objects_part.py:
⋮...
│class BasePartObject(Part):
│    """BasePartObject
│
│    Base class for all BuildPart objects & operations
│
│    Args:
│        solid (Solid): object to create
│        rotation (RotationLike, optional): angles to rotate about axes. Defaults to (0, 0, 0).
│        align (Union[Align, tuple[Align, Align, Align]], optional): align min, center,
│            or max of object. Defaults to None.
│        mode (Mode, optional): combination mode. Defaults to Mode.ADD.
⋮...
│    def __init__(
│        self,
│        part: Union[Part, Solid],
│        rotation: RotationLike = (0, 0, 0),
│        align: Union[Align, tuple[Align, Align, Align]] = None,
│        mode: Mode = Mode.ADD,
⋮...
│class Box(BasePartObject):
│    """Part Object: Box
│
│    Create a box(es) and combine with part.
│
│    Args:
│        length (float): box size
│        width (float): box size
│        height (float): box size
│        rotation (RotationLike, optional): angles to rotate about axes. Defaults to (0, 0, 0).
│        align (Union[Align, tuple[Align, Align, Align]], optional): align min, center,
⋮...
│    def __init__(
│        self,
│        length: float,
│        width: float,
│        height: float,
│        rotation: RotationLike = (0, 0, 0),
│        align: Union[Align, tuple[Align, Align, Align]] = (
│            Align.CENTER,
│            Align.CENTER,
│            Align.CENTER,
⋮...
│class Cone(BasePartObject):
│    """Part Object: Cone
│
│    Create a cone(s) and combine with part.
│
│    Args:
│        bottom_radius (float): cone size
│        top_radius (float): top size, could be zero
│        height (float): cone size
│        arc_size (float, optional): angular size of cone. Defaults to 360.
│        rotation (RotationLike, optional): angles to rotate about axes. Defaults to (0, 0, 0).
⋮...
│    def __init__(
│        self,
│        bottom_radius: float,
│        top_radius: float,
│        height: float,
│        arc_size: float = 360,
│        rotation: RotationLike = (0, 0, 0),
│        align: Union[Align, tuple[Align, Align, Align]] = (
│            Align.CENTER,
│            Align.CENTER,
⋮...
│class CounterBoreHole(BasePartObject):
│    """Part Operation: Counter Bore Hole
│
│    Create a counter bore hole in part.
│
│    Args:
│        radius (float): hole size
│        counter_bore_radius (float): counter bore size
│        counter_bore_depth (float): counter bore depth
│        depth (float, optional): hole depth - None implies through part. Defaults to None.
│        mode (Mode, optional): combination mode. Defaults to Mode.SUBTRACT.
⋮...
│    def __init__(
│        self,
│        radius: float,
│        counter_bore_radius: float,
│        counter_bore_depth: float,
│        depth: float = None,
│        mode: Mode = Mode.SUBTRACT,
⋮...
│class CounterSinkHole(BasePartObject):
│    """Part Operation: Counter Sink Hole
│
│    Create a counter sink hole in part.
│
│    Args:
│        radius (float): hole size
│        counter_sink_radius (float): counter sink size
│        depth (float, optional): hole depth - None implies through part. Defaults to None.
│        counter_sink_angle (float, optional): cone angle. Defaults to 82.
│        mode (Mode, optional): combination mode. Defaults to Mode.SUBTRACT.
⋮...
│    def __init__(
│        self,
│        radius: float,
│        counter_sink_radius: float,
│        depth: float = None,
│        counter_sink_angle: float = 82,  # Common tip angle
│        mode: Mode = Mode.SUBTRACT,
⋮...
│class Cylinder(BasePartObject):
│    """Part Object: Cylinder
│
│    Create a cylinder(s) and combine with part.
│
│    Args:
│        radius (float): cylinder size
│        height (float): cylinder size
│        arc_size (float, optional): angular size of cone. Defaults to 360.
│        rotation (RotationLike, optional): angles to rotate about axes. Defaults to (0, 0, 0).
│        align (Union[Align, tuple[Align, Align, Align]], optional): align min, center,
⋮...
│    def __init__(
│        self,
│        radius: float,
│        height: float,
│        arc_size: float = 360,
│        rotation: RotationLike = (0, 0, 0),
│        align: Union[Align, tuple[Align, Align, Align]] = (
│            Align.CENTER,
│            Align.CENTER,
│            Align.CENTER,
⋮...
│class Hole(BasePartObject):
│    """Part Operation: Hole
│
│    Create a hole in part.
│
│    Args:
│        radius (float): hole size
│        depth (float, optional): hole depth - None implies through part. Defaults to None.
│        mode (Mode, optional): combination mode. Defaults to Mode.SUBTRACT.
⋮...
│    def __init__(
│        self,
│        radius: float,
│        depth: float = None,
│        mode: Mode = Mode.SUBTRACT,
⋮...
│class Sphere(BasePartObject):
│    """Part Object: Sphere
│
│    Create a sphere(s) and combine with part.
│
│    Args:
│        radius (float): sphere size
│        arc_size1 (float, optional): angular size of sphere. Defaults to -90.
│        arc_size2 (float, optional): angular size of sphere. Defaults to 90.
│        arc_size3 (float, optional): angular size of sphere. Defaults to 360.
│        rotation (RotationLike, optional): angles to rotate about axes. Defaults to (0, 0, 0).
⋮...
│    def __init__(
│        self,
│        radius: float,
│        arc_size1: float = -90,
│        arc_size2: float = 90,
│        arc_size3: float = 360,
│        rotation: RotationLike = (0, 0, 0),
│        align: Union[Align, tuple[Align, Align, Align]] = (
│            Align.CENTER,
│            Align.CENTER,
⋮...
│class Torus(BasePartObject):
│    """Part Object: Torus
│
│    Create a torus(es) and combine with part.
│
│
│    Args:
│        major_radius (float): torus size
│        minor_radius (float): torus size
│        major_arc_size (float, optional): angular size of torus. Defaults to 0.
│        minor_arc_size (float, optional): angular size or torus. Defaults to 360.
⋮...
│    def __init__(
│        self,
│        major_radius: float,
│        minor_radius: float,
│        minor_start_angle: float = 0,
│        minor_end_angle: float = 360,
│        major_angle: float = 360,
│        rotation: RotationLike = (0, 0, 0),
│        align: Union[Align, tuple[Align, Align, Align]] = (
│            Align.CENTER,
⋮...
│class Wedge(BasePartObject):
│    """Part Object: Wedge
│
│    Create a wedge(s) and combine with part.
│
│    Args:
│        xsize (float): distance along the X axis
│        ysize (float): distance along the Y axis
│        zsize (float): distance along the Z axis
│        xmin (float): minimum X location
│        zmin (float): minimum Z location
⋮...
│    def __init__(
│        self,
│        xsize: float,
│        ysize: float,
│        zsize: float,
│        xmin: float,
│        zmin: float,
│        xmax: float,
│        zmax: float,
│        rotation: RotationLike = (0, 0, 0),
⋮...

src/build123d/objects_sketch.py:
⋮...
│class BaseSketchObject(Sketch):
│    """BaseSketchObject
│
│    Base class for all BuildSketch objects
│
│    Args:
│        face (Face): face to create
│        rotation (float, optional): angles to rotate objects. Defaults to 0.
│        align (Union[Align, tuple[Align, Align]], optional): align min, center, or max of object.
│            Defaults to None.
│        mode (Mode, optional): combination mode. Defaults to Mode.ADD.
⋮...
│    def __init__(
│        self,
│        obj: Union[Compound, Face],
│        rotation: float = 0,
│        align: Union[Align, tuple[Align, Align]] = None,
│        mode: Mode = Mode.ADD,
⋮...
│class Circle(BaseSketchObject):
│    """Sketch Object: Circle
│
│    Add circle(s) to the sketch.
│
│    Args:
│        radius (float): circle size
│        align (Union[Align, tuple[Align, Align]], optional): align min, center, or max of object.
│            Defaults to (Align.CENTER, Align.CENTER).
│        mode (Mode, optional): combination mode. Defaults to Mode.ADD.
⋮...
│    def __init__(
│        self,
│        radius: float,
│        align: Union[Align, tuple[Align, Align]] = (Align.CENTER, Align.CENTER),
│        mode: Mode = Mode.ADD,
⋮...
│class Ellipse(BaseSketchObject):
│    """Sketch Object: Ellipse
│
│    Add ellipse(s) to sketch.
│
│    Args:
│        x_radius (float): horizontal radius
│        y_radius (float): vertical radius
│        rotation (float, optional): angles to rotate objects. Defaults to 0.
│        align (Union[Align, tuple[Align, Align]], optional): align min, center, or max of object.
│            Defaults to (Align.CENTER, Align.CENTER).
⋮...
│    def __init__(
│        self,
│        x_radius: float,
│        y_radius: float,
│        rotation: float = 0,
│        align: Union[Align, tuple[Align, Align]] = (Align.CENTER, Align.CENTER),
│        mode: Mode = Mode.ADD,
⋮...
│class Polygon(BaseSketchObject):
│    """Sketch Object: Polygon
│
│    Add polygon(s) defined by given sequence of points to sketch.
│
│    Note that the order of the points define the normal of the Face that is created in
│    Algebra mode, where counter clockwise order creates Faces with their normal being up
│    while a clockwise order will have a normal that is down.  In Builder mode, all Faces
│    added to the sketch are up.
│
│    Args:
⋮...
│    def __init__(
│        self,
│        *pts: Union[VectorLike, Iterable[VectorLike]],
│        rotation: float = 0,
│        align: Union[Align, tuple[Align, Align]] = (Align.CENTER, Align.CENTER),
│        mode: Mode = Mode.ADD,
⋮...
│class Rectangle(BaseSketchObject):
│    """Sketch Object: Rectangle
│
│    Add rectangle(s) to sketch.
│
│    Args:
│        width (float): horizontal size
│        height (float): vertical size
│        rotation (float, optional): angles to rotate objects. Defaults to 0.
│        align (Union[Align, tuple[Align, Align]], optional): align min, center, or max of object.
│            Defaults to (Align.CENTER, Align.CENTER).
⋮...
│    def __init__(
│        self,
│        width: float,
│        height: float,
│        rotation: float = 0,
│        align: Union[Align, tuple[Align, Align]] = (Align.CENTER, Align.CENTER),
│        mode: Mode = Mode.ADD,
⋮...
│class RectangleRounded(BaseSketchObject):
│    """Sketch Object: RectangleRounded
│
│    Add rectangle(s) with filleted corners to sketch.
│
│    Args:
│        width (float): horizontal size
│        height (float): vertical size
│        radius (float): fillet radius
│        rotation (float, optional): angles to rotate objects. Defaults to 0.
│        align (Union[Align, tuple[Align, Align]], optional): align min, center, or max of object.
⋮...
│    def __init__(
│        self,
│        width: float,
│        height: float,
│        radius: float,
│        rotation: float = 0,
│        align: Union[Align, tuple[Align, Align]] = (Align.CENTER, Align.CENTER),
│        mode: Mode = Mode.ADD,
⋮...
│class RegularPolygon(BaseSketchObject):
│    """Sketch Object: Regular Polygon
│
│    Add regular polygon(s) to sketch.
│
│    Args:
│        radius (float): distance from origin to vertices (major), or
│            optionally from the origin to side (minor) with major_radius = False
│        side_count (int): number of polygon sides
│        major_radius (bool): If True the radius is the major radius, else the
│            radius is the minor radius (also known as inscribed radius).
⋮...
│    def __init__(
│        self,
│        radius: float,
│        side_count: int,
│        major_radius: bool = True,
│        rotation: float = 0,
│        align: tuple[Align, Align] = (Align.CENTER, Align.CENTER),
│        mode: Mode = Mode.ADD,
⋮...
│class SlotArc(BaseSketchObject):
│    """Sketch Object: Arc Slot
│
│    Add slot(s) following an arc to sketch.
│
│    Args:
│        arc (Union[Edge, Wire]): center line of slot
│        height (float): diameter of end circles
│        rotation (float, optional): angles to rotate objects. Defaults to 0.
│        mode (Mode, optional): combination mode. Defaults to Mode.ADD.
⋮...
│    def __init__(
│        self,
│        arc: Union[Edge, Wire],
│        height: float,
│        rotation: float = 0,
│        mode: Mode = Mode.ADD,
⋮...
│class SlotCenterPoint(BaseSketchObject):
│    """Sketch Object: Center Point Slot
│
│    Add a slot(s) defined by the center of the slot and the center of one of the
│    circular arcs at the end. The other end will be generated to create a symmetric
│    slot.
│
│    Args:
│        center (VectorLike): slot center point
│        point (VectorLike): slot center of arc point
│        height (float): diameter of end circles
⋮...
│    def __init__(
│        self,
│        center: VectorLike,
│        point: VectorLike,
│        height: float,
│        rotation: float = 0,
│        mode: Mode = Mode.ADD,
⋮...
│class SlotCenterToCenter(BaseSketchObject):
│    """Sketch Object: Center to Center points Slot
│
│    Add slot(s) defined by the distance between the center of the two
│    end arcs.
│
│    Args:
│        center_separation (float): distance between two arc centers
│        height (float): diameter of end circles
│        rotation (float, optional): angles to rotate objects. Defaults to 0.
│        mode (Mode, optional): combination mode. Defaults to Mode.ADD.
⋮...
│    def __init__(
│        self,
│        center_separation: float,
│        height: float,
│        rotation: float = 0,
│        mode: Mode = Mode.ADD,
⋮...
│class SlotOverall(BaseSketchObject):
│    """Sketch Object: Center to Center points Slot
│
│    Add slot(s) defined by the overall with of the slot.
│
│    Args:
│        width (float): overall width of the slot
│        height (float): diameter of end circles
│        rotation (float, optional): angles to rotate objects. Defaults to 0.
│        align (Union[Align, tuple[Align, Align]], optional): align min, center, or max of object.
│            Defaults to (Align.CENTER, Align.CENTER).
⋮...
│    def __init__(
│        self,
│        width: float,
│        height: float,
│        rotation: float = 0,
│        align: Union[Align, tuple[Align, Align]] = (Align.CENTER, Align.CENTER),
│        mode: Mode = Mode.ADD,
⋮...
│class Text(BaseSketchObject):
│    """Sketch Object: Text
│
│    Add text(s) to the sketch.
│
│    Args:
│        txt (str): text to be rendered
│        font_size (float): size of the font in model units
│        font (str, optional): font name. Defaults to "Arial".
│        font_path (str, optional): system path to font library. Defaults to None.
│        font_style (Font_Style, optional): style. Defaults to Font_Style.REGULAR.
⋮...
│    def __init__(
│        self,
│        txt: str,
│        font_size: float,
│        font: str = "Arial",
│        font_path: str = None,
│        font_style: FontStyle = FontStyle.REGULAR,
│        align: Union[Align, tuple[Align, Align]] = (Align.CENTER, Align.CENTER),
│        path: Union[Edge, Wire] = None,
│        position_on_path: float = 0.0,
⋮...
│class Trapezoid(BaseSketchObject):
│    """Sketch Object: Trapezoid
│
│    Add trapezoid(s) to the sketch.
│
│    Args:
│        width (float): horizontal width
│        height (float): vertical height
│        left_side_angle (float): bottom left interior angle
│        right_side_angle (float, optional): bottom right interior angle. If not provided,
│            the trapezoid will be symmetric. Defaults to None.
⋮...
│    def __init__(
│        self,
│        width: float,
│        height: float,
│        left_side_angle: float,
│        right_side_angle: float = None,
│        rotation: float = 0,
│        align: Union[Align, tuple[Align, Align]] = (Align.CENTER, Align.CENTER),
│        mode: Mode = Mode.ADD,
⋮...
│class Triangle(BaseSketchObject):
│    """Sketch Object: Triangle
│
│    Add any triangle to the sketch by specifying the length of any side and any
│    two other side lengths or interior angles. Note that the interior angles are
│    opposite the side with the same designation (i.e. side 'a' is opposite angle 'A').
│
│    Args:
│        a (float, optional): side 'a' length. Defaults to None.
│        b (float, optional): side 'b' length. Defaults to None.
│        c (float, optional): side 'c' length. Defaults to None.
⋮...
│    def __init__(
│        self,
│        *,
│        a: float = None,
│        b: float = None,
│        c: float = None,
│        A: float = None,
│        B: float = None,
│        C: float = None,
│        align: Union[None, Align, tuple[Align, Align]] = None,
⋮...

src/build123d/operations_generic.py:
⋮...
│def add(
│    objects: Union[AddType, Iterable[AddType]],
│    rotation: Union[float, RotationLike] = None,
│    clean: bool = True,
│    mode: Mode = Mode.ADD,
⋮...
│def bounding_box(
│    objects: Union[Shape, Iterable[Shape]] = None,
│    mode: Mode = Mode.PRIVATE,
⋮...
│def chamfer(
│    objects: Union[ChamferFilletType, Iterable[ChamferFilletType]],
│    length: float,
│    length2: float = None,
│    angle: float = None,
│    reference: Union[Edge, Face] = None,
⋮...
│def fillet(
│    objects: Union[ChamferFilletType, Iterable[ChamferFilletType]],
│    radius: float,
⋮...
│def mirror(
│    objects: Union[MirrorType, Iterable[MirrorType]] = None,
│    about: Plane = Plane.XZ,
│    mode: Mode = Mode.ADD,
⋮...
│def scale(
│    objects: Union[Shape, Iterable[Shape]] = None,
│    by: Union[float, tuple[float, float, float]] = 1,
│    mode: Mode = Mode.REPLACE,
⋮...
│def split(
│    objects: Union[SplitType, Iterable[SplitType]] = None,
│    bisect_by: Plane = Plane.XZ,
│    keep: Keep = Keep.TOP,
│    mode: Mode = Mode.REPLACE,
⋮...
│def sweep(
│    sections: Union[SweepType, Iterable[SweepType]] = None,
│    path: Union[Curve, Edge, Wire, Iterable[Edge]] = None,
│    multisection: bool = False,
│    is_frenet: bool = False,
│    transition: Transition = Transition.TRANSFORMED,
│    normal: VectorLike = None,
│    binormal: Union[Edge, Wire] = None,
│    clean: bool = True,
│    mode: Mode = Mode.ADD,
⋮...

src/build123d/operations_part.py:
⋮...
│def extrude(
│    to_extrude: Union[Face, Sketch] = None,
│    amount: float = None,
│    dir: VectorLike = None,  # pylint: disable=redefined-builtin
│    until: Until = None,
│    target: Union[Compound, Solid] = None,
│    both: bool = False,
│    taper: float = 0.0,
│    clean: bool = True,
│    mode: Mode = Mode.ADD,
⋮...
│def revolve(
│    profiles: Union[Face, Iterable[Face]] = None,
│    axis: Axis = Axis.Z,
│    revolution_arc: float = 360.0,
│    clean: bool = True,
│    mode: Mode = Mode.ADD,
⋮...
│def thicken(
│    to_thicken: Union[Face, Sketch] = None,
│    amount: float = None,
│    normal_override: VectorLike = None,
│    both: bool = False,
│    clean: bool = True,
│    mode: Mode = Mode.ADD,
⋮...

src/build123d/operations_sketch.py:
⋮...
│def make_face(
│    edges: Union[Edge, Iterable[Edge]] = None, mode: Mode = Mode.ADD
⋮...
│def trace(
│    lines: Union[Curve, Edge, Wire, Iterable[Union[Curve, Edge, Wire]]] = None,
│    line_width: float = 1,
│    mode: Mode = Mode.ADD,
⋮...

src/build123d/pack.py:
⋮...
│def _pack2d(
│    objects: Collection[object],
│    width_fn: Callable[[object], float],
│    length_fn: Callable[[object], float],
│) -> Collection[tuple[float, float]]:
│    """Takes an iterable of objects to pack into a square(ish) 2D
│    arrangement, and return a list of (x,y) locations to place each to
│    achieve the packing.
│    Based on https://codeincomplete.com/articles/bin-packing/ and
│    implemented as a straight-forward port of
│    https://github.com/jakesgordon/bin-packing/blob/master/js/packer.growing.js
⋮...
│    @dataclass
│    class _Node:
⋮...
│    def find_node(start, w, h):
⋮...
│    def split_node(node, w, h):
⋮...
│    def grow_node(w, h):
⋮...
│    def grow_right(w, h):
⋮...
│    def grow_down(w, h):
⋮...
│def pack(objects: Collection[Shape], padding: float, align_z: bool = False) -> Collection[Shape]:
│    """Pack objects in a squarish area in Plane.XY.
│
│    Args:
│        objects (Collection[Shape]): objects to arrange
│        padding (float): space between objects
│        align_z (bool, optional): align shape bottoms to Plane.XY. Defaults to False.
│
│    Returns:
│        Collection[Shape]: rearranged objects
⋮...
│    def _overlapping(bb1, bb2):
⋮...

src/build123d/persistence.py:
⋮...
│def serialize_shape(shape: TopoDS_Shape) -> bytes:
⋮...
│def serialize_location(location: TopLoc_Location) -> bytes:
⋮...
│def modify_copyreg():
⋮...

src/build123d/py.typed

src/build123d/topology.py:
⋮...
│def tuplify(obj: Any, dim: int) -> tuple:
⋮...
│class Mixin1D:
│    """Methods to add to the Edge and Wire classes"""
│
│    def start_point(self) -> Vector:
⋮...
│    def end_point(self) -> Vector:
⋮...
│    def param_at(self, distance: float) -> float:
⋮...
│    def tangent_at(
│        self,
│        position: Union[float, VectorLike] = 0.5,
│        position_mode: PositionMode = PositionMode.PARAMETER,
⋮...
│    def tangent_angle_at(
│        self,
│        location_param: float = 0.5,
│        position_mode: PositionMode = PositionMode.PARAMETER,
│        plane: Plane = Plane.XY,
⋮...
│    def center(self, center_of: CenterOf = CenterOf.GEOMETRY) -> Vector:
⋮...
│    def common_plane(self, *lines: Union[Edge, Wire]) -> Union[None, Plane]:
⋮...
│    def position_at(
│        self, distance: float, position_mode: PositionMode = PositionMode.PARAMETER
⋮...
│    def positions(
│        self,
│        distances: Iterable[float],
│        position_mode: PositionMode = PositionMode.PARAMETER,
⋮...
│    def location_at(
│        self,
│        distance: float,
│        position_mode: PositionMode = PositionMode.PARAMETER,
│        frame_method: FrameMethod = FrameMethod.FRENET,
│        planar: bool = False,
⋮...
│    def locations(
│        self,
│        distances: Iterable[float],
│        position_mode: PositionMode = PositionMode.PARAMETER,
│        frame_method: FrameMethod = FrameMethod.FRENET,
│        planar: bool = False,
⋮...
│    def offset_2d(
│        self,
│        distance: float,
│        kind: Kind = Kind.ARC,
│        side: Side = Side.BOTH,
│        closed: bool = True,
⋮...
│    def perpendicular_line(
│        self, length: float, u_value: float, plane: Plane = Plane.XY
⋮...
│class Mixin3D:
│    """Additional methods to add to 3D Shape classes"""
│
│    def fillet(self, radius: float, edge_list: Iterable[Edge]) -> Self:
⋮...
│    def max_fillet(
│        self,
│        edge_list: Iterable[Edge],
│        tolerance=0.1,
│        max_iterations: int = 10,
│    ) -> float:
│        """Find Maximum Fillet Size
│
│        Find the largest fillet radius for the given Shape and edges with a
│        recursive binary search.
│
│        Example:
│
│              max_fillet_radius = my_shape.max_fillet(shape_edges)
│              max_fillet_radius = my_shape.max_fillet(shape_edges, tolerance=0.5, max_iterations=8)
│
⋮...
│        def __max_fillet(window_min: float, window_max: float, current_iteration: int):
⋮...
│    def chamfer(
│        self,
│        length: float,
│        length2: Optional[float],
│        edge_list: Iterable[Edge],
│        face: Face = None,
⋮...
│    def center(self, center_of: CenterOf = CenterOf.MASS) -> Vector:
⋮...
│    def offset_3d(
│        self,
│        openings: Optional[Iterable[Face]],
│        thickness: float,
│        tolerance: float = 0.0001,
│        kind: Kind = Kind.ARC,
⋮...
│    def is_inside(self, point: VectorLike, tolerance: float = 1.0e-6) -> bool:
⋮...
│class Shape(NodeMixin):
│    """Shape
│
│    Base class for all CAD objects such as Edge, Face, Solid, etc.
│
│    Args:
│        obj (TopoDS_Shape, optional): OCCT object. Defaults to None.
│        label (str, optional): Defaults to ''.
│        color (Color, optional): Defaults to None.
│        parent (Compound, optional): assembly parent. Defaults to None.
│
⋮...
│    def __init__(
│        self,
│        obj: TopoDS_Shape = None,
│        label: str = "",
│        color: Color = None,
│        parent: Compound = None,
⋮...
│    class _DisplayNode(NodeMixin):
│        """Used to create anytree structures from TopoDS_Shapes"""
│
│        def __init__(
│            self,
│            label: str = "",
│            address: int = None,
│            position: Union[Vector, Location] = None,
│            parent: Shape._DisplayNode = None,
⋮...
│    @staticmethod
│    def _build_tree(
│        shape: TopoDS_Shape,
│        tree: list[_DisplayNode],
│        parent: _DisplayNode = None,
│        limit: TopAbs_ShapeEnum = TopAbs_ShapeEnum.TopAbs_VERTEX,
│        show_center: bool = True,
⋮...
│    @staticmethod
│    def _show_tree(root_node, show_center: bool) -> str:
⋮...
│    def center(self) -> Vector:
⋮...
│    def clean(self) -> Self:
⋮...
│    def fix(self) -> Self:
⋮...
│    @classmethod
│    def cast(cls, obj: TopoDS_Shape, for_construction: bool = False) -> Self:
⋮...
│    def hash_code(self) -> int:
⋮...
│    def is_null(self) -> bool:
⋮...
│    def is_same(self, other: Shape) -> bool:
⋮...
│    def __eq__(self, other) -> bool:
⋮...
│    def is_valid(self) -> bool:
⋮...
│    def bounding_box(self, tolerance: float = None) -> BoundBox:
⋮...
│    def mirror(self, mirror_plane: Plane = None) -> Self:
⋮...
│    @staticmethod
│    def compute_mass(obj: Shape) -> float:
⋮...
│    def _entities(self, topo_type: Shapes) -> list[TopoDS_Shape]:
⋮...
│    def vertices(self) -> ShapeList[Vertex]:
⋮...
│    def edges(self) -> ShapeList[Edge]:
⋮...
│    def edge(self) -> Edge:
⋮...
│    def compounds(self) -> ShapeList[Compound]:
⋮...
│    def wires(self) -> ShapeList[Wire]:
⋮...
│    def faces(self) -> ShapeList[Face]:
⋮...
│    def face(self) -> Face:
⋮...
│    def shells(self) -> ShapeList[Shell]:
⋮...
│    def solids(self) -> ShapeList[Solid]:
⋮...
│    def _apply_transform(self, transformation: gp_Trsf) -> Self:
⋮...
│    def rotate(self, axis: Axis, angle: float) -> Self:
⋮...
│    def translate(self, vector: VectorLike) -> Self:
⋮...
│    def scale(self, factor: float) -> Self:
⋮...
│    def copy(self) -> Self:
⋮...
│    def transform_shape(self, t_matrix: Matrix) -> Self:
⋮...
│    def transform_geometry(self, t_matrix: Matrix) -> Self:
⋮...
│    def locate(self, loc: Location) -> Self:
⋮...
│    def located(self, loc: Location) -> Self:
⋮...
│    def move(self, loc: Location) -> Self:
⋮...
│    def moved(self, loc: Location) -> Self:
⋮...
│    def distance_to_with_closest_points(
│        self, other: Union[Shape, VectorLike]
⋮...
│    def distance_to(self, other: Union[Shape, VectorLike]) -> float:
⋮...
│    def closest_points(self, other: Union[Shape, VectorLike]) -> tuple[Vector, Vector]:
⋮...
│    def _bool_op(
│        self,
│        args: Iterable[Shape],
│        tools: Iterable[Shape],
│        operation: Union[BRepAlgoAPI_BooleanOperation, BRepAlgoAPI_Splitter],
⋮...
│    def cut(self, *to_cut: Shape) -> Self:
⋮...
│    def fuse(self, *to_fuse: Shape, glue: bool = False, tol: float = None) -> Self:
⋮...
│    def intersect(self, *to_intersect: Union[Shape, Axis, Plane]) -> Shape:
⋮...
│    def split(self, plane: Plane, keep: Keep = Keep.TOP) -> Self:
⋮...
│    def mesh(self, tolerance: float, angular_tolerance: float = 0.1):
⋮...
│    def to_splines(
│        self, degree: int = 3, tolerance: float = 1e-3, nurbs: bool = False
⋮...
│    def to_vtk_poly_data(
│        self,
│        tolerance: float = None,
│        angular_tolerance: float = None,
│        normals: bool = False,
⋮...
│    def _repr_javascript_(self):
⋮...
│    def find_intersection(self, axis: Axis) -> list[tuple[Vector, Vector]]:
⋮...
│    def _extrude(
│        self, direction: VectorLike
⋮...
│    @classmethod
│    def extrude(
│        cls, obj: Union[Vertex, Edge, Wire, Face, Shell], direction: VectorLike
⋮...
│    def project_to_viewport(
│        self,
│        viewport_origin: VectorLike,
│        viewport_up: VectorLike = (0, 0, 1),
│        look_at: VectorLike = None,
│    ) -> tuple[ShapeList[Edge], ShapeList[Edge]]:
│        """project_to_viewport
│
│        Project a shape onto a viewport returning visible and hidden Edges.
│
│        Args:
│            viewport_origin (VectorLike): location of viewport
│            viewport_up (VectorLike, optional): direction of the viewport y axis.
│                Defaults to (0, 0, 1).
│            look_at (VectorLike, optional): point to look at.
│                Defaults to None (center of shape).
│
⋮...
│        def extract_edges(compound):
⋮...
│class Comparable(metaclass=ABCMeta):
│    """Abstract base class that requires comparison methods"""
│
⋮...
│    @abstractmethod
│    def __eq__(self, other: Any) -> bool: ...
│
⋮...
│class ShapeList(list[T]):
│    """Subclass of list with custom filter and sort methods appropriate to CAD"""
│
⋮...
│    def filter_by(
│        self,
│        filter_by: Union[ShapePredicate, Axis, Plane, GeomType],
│        reverse: bool = False,
│        tolerance: float = 1e-5,
│    ) -> ShapeList[T]:
│        """filter by Axis, Plane, or GeomType
│
│        Either:
│        - filter objects of type planar Face or linear Edge by their normal or tangent
│        (respectively) and sort the results by the given axis, or
│        - filter the objects by the provided type. Note that not all types apply to all
│        objects.
│
│        Args:
│            filter_by (Union[Axis,Plane,GeomType]): axis, plane, or geom type to filter
⋮...
│        def axis_parallel_predicate(axis: Axis, tolerance: float):
│            def pred(shape: Shape):
│                if isinstance(shape, Face) and shape.geom_type == GeomType.PLANE:
│                    shape_axis = Axis(shape.center(), shape.normal_at(None))
│                elif isinstance(shape, Edge) and shape.geom_type == GeomType.LINE:
│                    shape_axis = Axis(shape.position_at(0), shape.tangent_at(0))
│                else:
│                    return False
⋮...
│        def plane_parallel_predicate(plane: Plane, tolerance: float):
│            plane_axis = Axis(plane.origin, plane.z_dir)
⋮...
│            def pred(shape: Shape):
⋮...
│        if callable(filter_by):
⋮...
│        elif isinstance(filter_by, GeomType):
│
│            def predicate(obj):
⋮...
│    def filter_by_position(
│        self,
│        axis: Axis,
│        minimum: float,
│        maximum: float,
│        inclusive: tuple[bool, bool] = (True, True),
⋮...
│    def group_by(
│        self,
│        group_by: Union[Callable[[Shape], K], Axis, Edge, Wire, SortBy] = Axis.Z,
│        reverse=False,
│        tol_digits=6,
│    ) -> GroupBy[T, K]:
│        """group by
│
│        Group objects by provided criteria and then sort the groups according to the criteria.
│        Note that not all group_by criteria apply to all objects.
│
│        Args:
│            group_by (SortBy, optional): group and sort criteria. Defaults to Axis.Z.
│            reverse (bool, optional): flip order of sort. Defaults to False.
│            tol_digits (int, optional): Tolerance for building the group keys by
│                round(key, tol_digits)
│
⋮...
│        if isinstance(group_by, Axis):
│            axis_as_location = group_by.location.inverse()
│
│            def key_f(obj):
⋮...
│        elif isinstance(group_by, (Edge, Wire)):
│
│            def key_f(obj):
│                return round(
│                    group_by.param_at_point(obj.center()),
│                    tol_digits,
⋮...
│        elif isinstance(group_by, SortBy):
│            if group_by == SortBy.LENGTH:
│
│                def key_f(obj):
│                    return round(obj.length, tol_digits)
│
│            elif group_by == SortBy.RADIUS:
│
│                def key_f(obj):
│                    return round(obj.radius, tol_digits)
│
│            elif group_by == SortBy.DISTANCE:
│
│                def key_f(obj):
⋮...
│            elif group_by == SortBy.AREA:
│
│                def key_f(obj):
⋮...
│            elif group_by == SortBy.VOLUME:
│
│                def key_f(obj):
⋮...
│    def sort_by(
│        self, sort_by: Union[Axis, Edge, Wire, SortBy] = Axis.Z, reverse: bool = False
│    ) -> ShapeList[T]:
│        """sort by
│
│        Sort objects by provided criteria. Note that not all sort_by criteria apply to all
│        objects.
│
│        Args:
│            sort_by (SortBy, optional): sort criteria. Defaults to SortBy.Z.
│            reverse (bool, optional): flip order of sort. Defaults to False.
│
│        Returns:
⋮...
│        if isinstance(sort_by, Axis):
⋮...
│        elif isinstance(sort_by, (Edge, Wire)):
│
│            def u_of_closest_center(obj) -> float:
│                """u-value of closest point between object center and sort_by"""
│                pnt1, _pnt2 = sort_by.closest_points(obj.center())
⋮...
│    def sort_by_distance(
│        self, other: Union[Shape, VectorLike], reverse: bool = False
⋮...
│    def vertices(self) -> ShapeList[Vertex]:
⋮...
│    def edges(self) -> ShapeList[Edge]:
⋮...
│    def edge(self) -> Edge:
⋮...
│    def wires(self) -> ShapeList[Wire]:
⋮...
│    def faces(self) -> ShapeList[Face]:
⋮...
│    def face(self) -> Face:
⋮...
│    def shells(self) -> ShapeList[Shell]:
⋮...
│    def solids(self) -> ShapeList[Solid]:
⋮...
│    def compounds(self) -> ShapeList[Compound]:
⋮...
│    def __eq__(self, other: ShapeList):
⋮...
│    @overload
│    def __getitem__(self, key: int) -> T: ...
│
│    @overload
│    def __getitem__(self, key: slice) -> ShapeList[T]: ...
│
│    def __getitem__(self, key: Union[int, slice]) -> Union[T, ShapeList[T]]:
⋮...
│class GroupBy(Generic[T, K]):
│    """Result of a Shape.groupby operation. Groups can be accessed by index or key"""
│
│    def __init__(
│        self,
│        key_f: Callable[[T], K],
│        shapelist: Iterable[T],
│        *,
│        reverse: bool = False,
⋮...
│    def __getitem__(self, key: int):
⋮...
│    def group(self, key: K):
⋮...
│class Compound(Mixin3D, Shape):
│    """A Compound in build123d is a topological entity representing a collection of
│    geometric shapes grouped together within a single structure. It serves as a
│    container for organizing diverse shapes like edges, faces, or solids. This
│    hierarchical arrangement facilitates the construction of complex models by
│    combining simpler shapes. Compound plays a pivotal role in managing the
│    composition and structure of intricate 3D models in computer-aided design
│    (CAD) applications, allowing engineers and designers to work with assemblies
⋮...
│    @overload
│    def __init__(
│        self,
│        obj: TopoDS_Shape,
│        label: str = "",
│        color: Color = None,
│        material: str = "",
│        joints: dict[str, Joint] = None,
│        parent: Compound = None,
│        children: Iterable[Shape] = None,
⋮...
│    @overload
│    def __init__(
│        self,
│        shapes: Iterable[Shape],
│        label: str = "",
│        color: Color = None,
│        material: str = "",
│        joints: dict[str, Joint] = None,
│        parent: Compound = None,
│        children: Iterable[Shape] = None,
⋮...
│    def __init__(self, *args, **kwargs):
⋮...
│    def center(self, center_of: CenterOf = CenterOf.MASS) -> Vector:
⋮...
│    @staticmethod
│    def _make_compound(occt_shapes: Iterable[TopoDS_Shape]) -> TopoDS_Compound:
⋮...
│    @classmethod
│    def make_text(
│        cls,
│        txt: str,
│        font_size: float,
│        font: str = "Arial",
│        font_path: Optional[str] = None,
│        font_style: FontStyle = FontStyle.REGULAR,
│        align: Union[Align, tuple[Align, Align]] = (Align.CENTER, Align.CENTER),
│        position_on_path: float = 0.0,
│        text_path: Union[Edge, Wire] = None,
│    ) -> "Compound":
│        """2D Text that optionally follows a path.
│
│        The text that is created can be combined as with other sketch features by specifying
│        a mode or rotated by the given angle.  In addition, edges have been previously created
│        with arc or segment, the text will follow the path defined by these edges. The start
│        parameter can be used to shift the text along the path to achieve precise positioning.
│
│        Args:
│            txt: text to be rendered
│            font_size: size of the font in model units
⋮...
│        def position_face(orig_face: "Face") -> "Face":
⋮...
│    @classmethod
│    def make_triad(cls, axes_scale: float) -> Compound:
⋮...
│    def cut(self, *to_cut: Shape) -> Compound:
⋮...
│    def fuse(self, *to_fuse: Shape, glue: bool = False, tol: float = None) -> Compound:
⋮...
│    def intersect(self, *to_intersect: Shape) -> Compound:
⋮...
│    def get_type(
│        self,
│        obj_type: Union[Type[Edge], Type[Face], Type[Shell], Type[Solid], Type[Wire]],
⋮...
│class Part(Compound):
⋮...
│class Sketch(Compound):
⋮...
│class Curve(Compound):
│    """A Compound containing 1D objects - aka Edges"""
│
⋮...
│    def wires(self) -> list[Wire]:
⋮...
│class Edge(Mixin1D, Shape):
│    """An Edge in build123d is a fundamental element in the topological data structure
│    representing a one-dimensional geometric entity within a 3D model. It encapsulates
│    information about a curve, which could be a line, arc, or other parametrically
│    defined shape. Edge is crucial in for precise modeling and manipulation of curves,
│    facilitating operations like filleting, chamfering, and Boolean operations. It
│    serves as a building block for constructing complex structures, such as wires
⋮...
│    def _geom_adaptor(self) -> BRepAdaptor_Curve:
⋮...
│    def close(self) -> Union[Edge, Wire]:
⋮...
│    def to_wire(self) -> Wire:
⋮...
│    def intersections(
│        self, edge: Union[Axis, Edge] = None, tolerance: float = TOLERANCE
⋮...
│    def reversed(self) -> Edge:
⋮...
│    def trim(self, start: float, end: float) -> Edge:
⋮...
│    def param_at_point(self, point: VectorLike) -> float:
│        """Parameter at point of Edge"""
│
│        def _project_point_on_curve(curve, gp_pnt) -> float:
⋮...
│    @classmethod
│    def make_bezier(cls, *cntl_pnts: VectorLike, weights: list[float] = None) -> Edge:
⋮...
│    @classmethod
│    def make_circle(
│        cls,
│        radius: float,
│        plane: Plane = Plane.XY,
│        start_angle: float = 360.0,
│        end_angle: float = 360,
│        angular_direction: AngularDirection = AngularDirection.COUNTER_CLOCKWISE,
⋮...
│    @classmethod
│    def make_ellipse(
│        cls,
│        x_radius: float,
│        y_radius: float,
│        plane: Plane = Plane.XY,
│        start_angle: float = 360.0,
│        end_angle: float = 360.0,
│        angular_direction: AngularDirection = AngularDirection.COUNTER_CLOCKWISE,
⋮...
│    @classmethod
│    def make_spline(
│        cls,
│        points: list[VectorLike],
│        tangents: list[VectorLike] = None,
│        periodic: bool = False,
│        parameters: list[float] = None,
│        scale: bool = True,
│        tol: float = 1e-6,
⋮...
│    @classmethod
│    def make_three_point_arc(
│        cls, point1: VectorLike, point2: VectorLike, point3: VectorLike
⋮...
│    @classmethod
│    def make_tangent_arc(
│        cls, start: VectorLike, tangent: VectorLike, end: VectorLike
⋮...
│    @classmethod
│    def make_line(cls, point1: VectorLike, point2: VectorLike) -> Edge:
⋮...
│    @classmethod
│    def make_helix(
│        cls,
│        pitch: float,
│        height: float,
│        radius: float,
│        center: VectorLike = (0, 0, 0),
│        normal: VectorLike = (0, 0, 1),
│        angle: float = 0.0,
│        lefthand: bool = False,
⋮...
│    def project_to_shape(
│        self,
│        target_object: Shape,
│        direction: VectorLike = None,
│        center: VectorLike = None,
⋮...
│    def to_axis(self) -> Axis:
⋮...
│class Face(Shape):
│    """A Face in build123d represents a 3D bounded surface within the topological data
│    structure. It encapsulates geometric information, defining a face of a 3D shape.
│    These faces are integral components of complex structures, such as solids and
│    shells. Face enables precise modeling and manipulation of surfaces, supporting
⋮...
│    @overload
│    def __init__(
│        self,
│        obj: TopoDS_Shape,
│        label: str = "",
│        color: Color = None,
│        parent: Compound = None,
⋮...
│    @overload
│    def __init__(
│        self,
│        outer_wire: Wire,
│        inner_wires: Iterable[Wire] = None,
│        label: str = "",
│        color: Color = None,
│        parent: Compound = None,
⋮...
│    def __init__(self, *args, **kwargs):
⋮...
│    def _geom_adaptor(self) -> Geom_Surface:
⋮...
│    def _uv_bounds(self) -> Tuple[float, float, float, float]:
⋮...
│    @overload
│    def normal_at(self, surface_point: VectorLike = None) -> Vector:
⋮...
│    @overload
│    def normal_at(self, u: float, v: float) -> Vector:
⋮...
│    def normal_at(self, *args, **kwargs) -> Vector:
⋮...
│    def position_at(self, u: float, v: float) -> Vector:
⋮...
│    def center(self, center_of=CenterOf.GEOMETRY) -> Vector:
⋮...
│    def outer_wire(self) -> Wire:
⋮...
│    def inner_wires(self) -> ShapeList[Wire]:
⋮...
│    @classmethod
│    def make_rect(cls, width: float, height: float, plane: Plane = Plane.XY) -> Face:
⋮...
│    @classmethod
│    def make_plane(
│        cls,
│        plane: Plane = Plane.XY,
⋮...
│    @classmethod
│    def _make_from_wires(
│        cls, outer_wire: Wire, inner_wires: Iterable[Wire] = None
⋮...
│    @classmethod
│    def sew_faces(cls, faces: Iterable[Face]) -> list[ShapeList[Face]]:
⋮...
│    @classmethod
│    def sweep(
│        cls,
│        profile: Union[Edge, Wire],
│        path: Union[Edge, Wire],
│        transition=Transition.RIGHT,
⋮...
│    def fillet_2d(self, radius: float, vertices: Iterable[Vertex]) -> Face:
⋮...
│    def chamfer_2d(
│        self,
│        distance: float,
│        distance2: float,
│        vertices: Iterable[Vertex],
│        edge: Edge = None,
⋮...
│    def is_coplanar(self, plane: Plane) -> bool:
⋮...
│    def thicken(self, depth: float, normal_override: VectorLike = None) -> Solid:
⋮...
│    def project_to_shape(
│        self, target_object: Shape, direction: VectorLike, taper: float = 0
⋮...
│    def project_to_shape_alt(
│        self, target_object: Shape, direction: VectorLike
│    ) -> Union[None, Face, Compound]:
│        """project_to_shape_alt
│
│        Return the Faces contained within the first projection of self onto
│        the target.
│
│        Args:
│            target_object (Shape): Object to project onto
│            direction (VectorLike): projection direction
│
│        Returns:
⋮...
│        def get(los: TopTools_ListOfShape, shape_cls) -> list:
⋮...
│        def desired_faces(face_list: list[Face]) -> bool:
⋮...
│    def is_inside(self, point: VectorLike, tolerance: float = 1.0e-6) -> bool:
⋮...
│class Shell(Shape):
│    """A Shell is a fundamental component in build123d's topological data structure
│    representing a connected set of faces forming a closed surface in 3D space. As
│    part of a geometric model, it defines a watertight enclosure, commonly encountered
│    in solid modeling. Shells group faces in a coherent manner, playing a crucial role
│    in representing complex shapes with voids and surfaces. This hierarchical structure
│    allows for efficient handling of surfaces within a model, supporting various
⋮...
│    @overload
│    def __init__(
│        self,
│        obj: TopoDS_Shape,
│        label: str = "",
│        color: Color = None,
│        parent: Compound = None,
⋮...
│    @overload
│    def __init__(
│        self,
│        face: Face,
│        label: str = "",
│        color: Color = None,
│        parent: Compound = None,
⋮...
│    @overload
│    def __init__(
│        self,
│        faces: Iterable[Face],
│        label: str = "",
│        color: Color = None,
│        parent: Compound = None,
⋮...
│    def __init__(self, *args, **kwargs):
⋮...
│    @classmethod
│    def make_shell(cls, faces: Iterable[Face]) -> Shell:
⋮...
│    @classmethod
│    def _make_shell(cls, faces: Iterable[Face]) -> TopoDS_Shape:
⋮...
│    def center(self) -> Vector:
⋮...
│class Solid(Mixin3D, Shape):
│    """A Solid in build123d represents a three-dimensional solid geometry
│    in a topological structure. A solid is a closed and bounded volume, enclosing
│    a region in 3D space. It comprises faces, edges, and vertices connected in a
│    well-defined manner. Solid modeling operations, such as Boolean
│    operations (union, intersection, and difference), are often performed on
⋮...
│    @overload
│    def __init__(
│        self,
│        obj: TopoDS_Shape,
│        label: str = "",
│        color: Color = None,
│        material: str = "",
│        joints: dict[str, Joint] = None,
│        parent: Compound = None,
⋮...
│    @overload
│    def __init__(
│        self,
│        shell: Shell,
│        label: str = "",
│        color: Color = None,
│        material: str = "",
│        joints: dict[str, Joint] = None,
│        parent: Compound = None,
⋮...
│    def __init__(self, *args, **kwargs):
⋮...
│    @classmethod
│    def make_solid(cls, shell: Shell) -> Solid:
⋮...
│    @classmethod
│    def _make_solid(cls, shell: Shell) -> TopoDS_Solid:
⋮...
│    @classmethod
│    def from_bounding_box(cls, bbox: BoundBox) -> Solid:
⋮...
│    @classmethod
│    def make_box(
│        cls, length: float, width: float, height: float, plane: Plane = Plane.XY
⋮...
│    @classmethod
│    def make_cone(
│        cls,
│        base_radius: float,
│        top_radius: float,
│        height: float,
│        plane: Plane = Plane.XY,
│        angle: float = 360,
⋮...
│    @classmethod
│    def make_cylinder(
│        cls,
│        radius: float,
│        height: float,
│        plane: Plane = Plane.XY,
│        angle: float = 360,
⋮...
│    @classmethod
│    def make_torus(
│        cls,
│        major_radius: float,
│        minor_radius: float,
│        plane: Plane = Plane.XY,
│        start_angle: float = 0,
│        end_angle: float = 360,
│        major_angle: float = 360,
⋮...
│    @classmethod
│    def make_loft(
│        cls, objs: Iterable[Union[Vertex, Wire]], ruled: bool = False
⋮...
│    @classmethod
│    def make_wedge(
│        cls,
│        delta_x: float,
│        delta_y: float,
│        delta_z: float,
│        min_x: float,
│        min_z: float,
│        max_x: float,
│        max_z: float,
│        plane: Plane = Plane.XY,
⋮...
│    @classmethod
│    def make_sphere(
│        cls,
│        radius: float,
│        plane: Plane = Plane.XY,
│        angle1: float = -90,
│        angle2: float = 90,
│        angle3: float = 360,
⋮...
│    @classmethod
│    def extrude_taper(
│        cls, profile: Face, direction: VectorLike, taper: float, flip_inner: bool = True
⋮...
│    @classmethod
│    def extrude_linear_with_rotation(
│        cls,
│        section: Union[Face, Wire],
│        center: VectorLike,
│        normal: VectorLike,
│        angle: float,
│        inner_wires: list[Wire] = None,
│    ) -> Solid:
│        """Extrude with Rotation
│
│        Creates a 'twisted prism' by extruding, while simultaneously rotating around the
│        extrusion vector.
│
│        Args:
│            section (Union[Face,Wire]): cross section
│            vec_center (VectorLike): the center point about which to rotate
│            vec_normal (VectorLike): a vector along which to extrude the wires
│            angle (float): the angle to rotate through while extruding
⋮...
│        def extrude_aux_spine(
│            wire: TopoDS_Wire, spine: TopoDS_Wire, aux_spine: TopoDS_Wire
⋮...
│    @classmethod
│    def extrude_until(
│        cls,
│        section: Face,
│        target_object: Union[Compound, Solid],
│        direction: VectorLike,
│        until: Until = Until.NEXT,
⋮...
│    @classmethod
│    def revolve(
│        cls,
│        section: Union[Face, Wire],
│        angle: float,
│        axis: Axis,
│        inner_wires: list[Wire] = None,
⋮...
│    @classmethod
│    def _set_sweep_mode(
│        cls,
│        builder: BRepOffsetAPI_MakePipeShell,
│        path: Union[Wire, Edge],
│        mode: Union[Vector, Wire, Edge],
⋮...
│    @classmethod
│    def sweep(
│        cls,
│        section: Union[Face, Wire],
│        path: Union[Wire, Edge],
│        inner_wires: list[Wire] = None,
│        make_solid: bool = True,
│        is_frenet: bool = False,
│        mode: Union[Vector, Wire, Edge, None] = None,
│        transition: Transition = Transition.TRANSFORMED,
⋮...
│    @classmethod
│    def sweep_multi(
│        cls,
│        profiles: Iterable[Union[Wire, Face]],
│        path: Union[Wire, Edge],
│        make_solid: bool = True,
│        is_frenet: bool = False,
│        mode: Union[Vector, Wire, Edge, None] = None,
⋮...
│class Vertex(Shape):
│    """A Vertex in build123d represents a zero-dimensional point in the topological
│    data structure. It marks the endpoints of edges within a 3D model, defining precise
│    locations in space. Vertices play a crucial role in defining the geometry of objects
│    and the connectivity between edges, facilitating accurate representation and
│    manipulation of 3D shapes. They hold coordinate information and are essential
⋮...
│    @overload
│    def __init__(self):  # pragma: no cover
⋮...
│    @overload
│    def __init__(self, v: TopoDS_Vertex):  # pragma: no cover
⋮...
│    @overload
│    def __init__(self, X: float, Y: float, Z: float):  # pragma: no cover
⋮...
│    @overload
│    def __init__(self, v: Iterable[float]):
⋮...
│    @overload
│    def __init__(self, v: tuple[float]):
⋮...
│    def __init__(self, *args, **kwargs):
⋮...
│    def to_tuple(self) -> tuple[float, float, float]:
⋮...
│    def center(self) -> Vector:
⋮...
│class Wire(Mixin1D, Shape):
│    """A Wire in build123d is a topological entity representing a connected sequence
│    of edges forming a continuous curve or path in 3D space. Wires are essential
│    components in modeling complex objects, defining boundaries for surfaces or
│    solids. They store information about the connectivity and order of edges,
⋮...
│    @overload
│    def __init__(
│        self,
│        obj: TopoDS_Shape,
│        label: str = "",
│        color: Color = None,
│        parent: Compound = None,
⋮...
│    @overload
│    def __init__(
│        self,
│        edge: Edge,
│        label: str = "",
│        color: Color = None,
│        parent: Compound = None,
⋮...
│    @overload
│    def __init__(
│        self,
│        wire: Wire,
│        label: str = "",
│        color: Color = None,
│        parent: Compound = None,
⋮...
│    @overload
│    def __init__(
│        self,
│        wire: Curve,
│        label: str = "",
│        color: Color = None,
│        parent: Compound = None,
⋮...
│    @overload
│    def __init__(
│        self,
│        edges: Iterable[Edge],
│        sequenced: bool = False,
│        label: str = "",
│        color: Color = None,
│        parent: Compound = None,
⋮...
│    def __init__(self, *args, **kwargs):
⋮...
│    def _geom_adaptor(self) -> BRepAdaptor_CompCurve:
⋮...
│    def close(self) -> Wire:
⋮...
│    def to_wire(self) -> Wire:
⋮...
│    @classmethod
│    def combine(
│        cls, wires: Iterable[Union[Wire, Edge]], tol: float = 1e-9
⋮...
│    def fix_degenerate_edges(self, precision: float) -> Wire:
⋮...
│    def param_at_point(self, point: VectorLike) -> float:
⋮...
│    def trim(self, start: float, end: float) -> Wire:
⋮...
│    def order_edges(self) -> ShapeList[Edge]:
⋮...
│    @classmethod
│    def _make_wire(cls, edges: Iterable[Edge], sequenced: bool = False) -> TopoDS_Wire:
│        """_make_wire
│
│        Build a Wire from the provided unsorted Edges. If sequenced is True the
│        Edges are placed in such that the end of the nth Edge is coincident with
│        the n+1th Edge forming an unbroken sequence. Note that sequencing a list
│        is relatively slow.
│
│        Args:
│            edges (Iterable[Edge]): Edges to assemble
│            sequenced (bool, optional): arrange in order. Defaults to False.
│
⋮...
│        def closest_to_end(current: Wire, unplaced_edges: list[Edge]) -> Edge:
⋮...
│    @classmethod
│    def make_circle(cls, radius: float, plane: Plane = Plane.XY) -> Wire:
⋮...
│    @classmethod
│    def make_ellipse(
│        cls,
│        x_radius: float,
│        y_radius: float,
│        plane: Plane = Plane.XY,
│        start_angle: float = 360.0,
│        end_angle: float = 360.0,
│        angular_direction: AngularDirection = AngularDirection.COUNTER_CLOCKWISE,
│        closed: bool = True,
⋮...
│    @classmethod
│    def make_polygon(cls, vertices: Iterable[VectorLike], close: bool = True) -> Wire:
⋮...
│    def fillet_2d(self, radius: float, vertices: Iterable[Vertex]) -> Wire:
⋮...
│    def chamfer_2d(
│        self,
│        distance: float,
│        distance2: float,
│        vertices: Iterable[Vertex],
│        edge: Edge = None,
⋮...
│    @classmethod
│    def make_rect(
│        cls,
│        width: float,
│        height: float,
│        plane: Plane = Plane.XY,
⋮...
│    @classmethod
│    def make_convex_hull(cls, edges: Iterable[Edge], tolerance: float = 1e-3) -> Wire:
⋮...
│    def project_to_shape(
│        self,
│        target_object: Shape,
│        direction: VectorLike = None,
│        center: VectorLike = None,
⋮...
│class Joint(ABC):
│    """Joint
│
│    Abstract Base Joint class - used to join two components together
│
│    Args:
│        parent (Union[Solid, Compound]): object that joint to bound to
│
│    Attributes:
│        label (str): user assigned label
│        parent (Shape): object joint is bound to
⋮...
│    def __init__(self, label: str, parent: Union[Solid, Compound]):
⋮...
│    def _connect_to(self, other: Joint, **kwargs):  # pragma: no cover
⋮...
│    @abstractmethod
│    def relative_to(self, other: Joint) -> Location:
⋮...
│def downcast(obj: TopoDS_Shape) -> TopoDS_Shape:
⋮...
│def edges_to_wires(edges: Iterable[Edge], tol: float = 1e-6) -> list[Wire]:
⋮...
│def fix(obj: TopoDS_Shape) -> TopoDS_Shape:
⋮...
│def shapetype(obj: TopoDS_Shape) -> TopAbs_ShapeEnum:
⋮...
│def unwrapped_shapetype(obj: Shape) -> TopAbs_ShapeEnum:
⋮...
│def sort_wires_by_build_order(wire_list: list[Wire]) -> list[list[Wire]]:
⋮...
│def new_edges(*objects: Shape, combined: Shape) -> ShapeList[Edge]:
⋮...
│def topo_explore_connected_edges(edge: Edge, parent: Shape = None) -> ShapeList[Edge]:
⋮...
│def topo_explore_common_vertex(
│    edge1: Union[Edge, TopoDS_Edge], edge2: Union[Edge, TopoDS_Edge]
⋮...
│class SkipClean:
│    """Skip clean context for use in operator driven code where clean=False wouldn't work"""
│
⋮...
│    def __enter__(self):
⋮...
│    def __exit__(self, exception_type, exception_value, traceback):
⋮...

src/build123d/version.py

